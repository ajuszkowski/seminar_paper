\documentclass[article]{aaltoseries}
\usepackage[utf8]{inputenc} % or \usepackage{fontspec}
\usepackage{enumitem}  % remove spaces before enumerations and lists
\usepackage{url}
%\usepackage{inconsolata}  % for mono font
\usepackage{amssymb}  % for negated \vdash
\usepackage{amsmath}  % for multi-line equations


\usepackage{listings,multicol}  % for code snippets
%\definecolor{light-gray}{black}{0.5}
\lstset{ 
	basicstyle=\footnotesize\ttfamily,
	%numbers=left,
	tabsize=2,
	frame=rltb,
	showspaces=false,
	showstringspaces=false,
	breaklines=true,
%	multicols=2,
	xleftmargin=2em,
	captionpos=b,
	rulecolor=\color{gray},
	escapeinside={[*}{*]}
} % setup listings package
\renewcommand*\lstlistingname{Figure}

%\usepackage{parcolumns} %\usepackage{paracol} %for 2-column listings, not installed

\usepackage{chngcntr}
%\usepackage{color}
\usepackage{courier}  % fix the error `pdflatex (file t1xtt): Font t1xtt at 600 not found`

\begin{document}
\counterwithin{lstlisting}{section}

%=========================================================

\title{Comparison of Theorem Provers}

\author{Artem Yushkovskiy
\\\textnormal{\texttt{artem.yushkovskiy@aalto.fi}}}

\affiliation{\textbf{Tutor}: Stavros Tripakis}

\maketitle

%==========================================================


\begin{abstract}

The need for formal definition of the very basis of mathematics arose in the last century.
The scale and complexity of mathematics, along with discovered paradoxes, revealed the danger of accumulating errors across theories. Although, according to Gödel's incompleteness theorems, it is not possible to construct a single formal system which will describe all phenomena in the world, being complete and consistent at the same time, that crisis has considerably improved philosophical views on mathematics. 
In addition, it gave rise to rather practical areas of logic, such as the theory of automated theorem proving. This is a set of techniques used to verify mathematical statements mechanically using logical reasoning. Moreover, it can be used to solve complex engineering problems as well, for instance, to prove the security properties of a software system or an algorithm.
This paper compares two widespread tools for automated theorem proving, Coq~\cite{tool_Coq} and Isabelle/HOL~\cite{tool_Isabelle}, with respect to the power of expressiveness and usability. For this reason, it firstly gives a brief introduction to the bases of formal systems and automated deduction theory, its main problems and challenges.

\vspace{3mm}
\noindent KEYWORDS: logic, formal method, proof theory, automated theorem prover, Coq, Isabelle.
	
\end{abstract}

%============================================================


\section{Introduction}

Nowadays, the search for foundations of mathematics has become one of the key questions in philosophy of mathematics, which eventually has an impact on numerous problems in modern life. Basically, this search has led to the development of \textit{formal approach}, a methodology for manipulating the abstract essences according basic rules in a verifiable way. In other words, it is possible to follow the sequence of such manipulations in order to check the validity of each statement and, as a result, of a system at whole. Moreover, automating such a verification process can significantly increase reliability of formal models and systems based on them.

At present, a large number of tools have been developed to automate this process. Generally, these tools can be divided into two broad classes. 

The first class contains tools pursuing the aim of validating the input statement (\textit{theorem}) with respect to the sequence of inference transitions (user-defined \textit{proof}) according to set of inference rules. Such tools are sometimes called \textit{proof assistants}, their purpose is to help users to develop new proofs. The tools \textit{Isabelle}~\cite{tool_Isabelle}, \textit{Coq}~\cite{tool_Coq}, \textit{PVS}~\cite{tool_Pvs} are well-known examples of such systems, which are commonly used in recent years.

The second class consists of tools that automatically \textit{discover} the formal proof, which can rely either on induction, on meta argument, or on higher-order logic. Such tools are often called \textit{automated theorem provers}, they apply techniques of automated logical reasoning to develop the proof. The systems \textit{Otter}~\cite{tool_Otter} and \textit{ACL2}~\cite{tool_Acl} are commonly known examples of such tools.

In this paper, only systems of the first class were considered in order to test the usability of such systems.

%------------------------------------------------------------


\subsection{Related work}
A considerably extensive survey on theorem provers has been presented by F.~Wiedijk~\cite{Wie03}, where fifteen 'state-of-the-art' systems for the formalization of mathematics were compared against various properties, in particular size of library with already proved lemmas, strength and expressiveness of underlying logic, size of proofs (the de Bruijn criterion) and level of automation (the Poincaré principle). We propose more deep comparison of two aforementioned theorem provers -- Coq and Isabelle -- with respect to criteria, such as expressiveness, computation power and usability. Section~\ref{sec:formal_theory} provides definition, basic properties and theoretical limitations of the formal systems, while Section~\ref{sec:comparison} presents target comparison properties and the comparison itself.


%============================================================


\section{Foundations of Formal Approach}
\label{sec:formal_theory}

The formal approach appeared in the beginning of previous century when mathematics experienced deep fundamental crisis caused by the need for a formal definition of the very basis. At that time, multiple paradoxes in several fields of mathematics have been discovered. Moreover, the radically new theories appeared just by modification of the set of axioms, e.g., reducing the parallel postulate of Euclidean geometry has lead to completely different non-Euclidian geometries, such as Lobachevsky's hyperbolic geometry or Riemman's elliptic geometry, that eventually have a large number of applications in both natural sciences and engineering.


\subsection{Definition of the Formal System}
\label{sec:definitions}

% TODO: add citations!

%\texttt{Definition.}
Let the \textit{judgement} be an arbitrary statement. The \textit{formal proof} of the formula $\phi$ is a finite sequence of judgements $ ( \psi_i )_{i=1}^{n} $, where each $\psi_i$ is either an axiom $A_i$, or a formula inferred from the subset $\{ \psi_k \}_{k=1}^{i-1}$ of previously derived formulae according the \textit{rules of inference}. \textit{An axiom} $A_i \in A$ is a judgement evidently claimed to be true. \textit{A logical inference} is a transfer from one judgement (\textit{premise}) to another (\textit{consequence}), which preserves truth. In formal logic, inference is based entirely on the structure of those judgements, thereby, the result formal system represents the abstract model describing part of real world. 

As an example of inference rule, the widely used \textit{Modus ponens} (MP) rule can be considered: ${ {\frac {A,\ (A\rightarrow B)}{B}}}$. In this standard notation, the premises are enumerated above the horizontal line and consequences -- below it. We will use this notation further. 
% TODO: check whether we actually use it
% --

The formulae consist of \textit{propositional variables}, connected with \textit{logical connectives} (or logical operators) according to rules, defined by a formal language. The formulae, which satisfy such rules, are called \textit{well-formed formulae} (wff). Only wff can form judgements in a formal system. The propositional variable is an atomic formula which can be either true or false. The logical connective is a symbol in formal language that transforms one wff to another. Typically, the set of logical connectives contains negation $\neg$, conjunction $\land$, disjunction $\lor$, and implication $\rightarrow$ operators, although the combination of negation operator with any other of aforementioned operators will be already functionally complete (i.e., any formula can be represented with the usage of these two logical connectives).

The formal system described above does not contain any restriction on the form of propositional variables, such logic is called \textit{propositional logic}. However, if these variables are quantified on the sets, such logic is called \textit{first-order} or \textit{predicate logic}. Commonly, first-order logic has two quantifiers, the universal quantifier $\forall$ (means "for every"), and the existential quantifier $\exists$ (means "there exists"). Thereafter, the \textit{second-order logic} extends first-order logic by adding quantifiers over second-order objects -- relations defining the sets of sets. In turn, it can be extended by the \textit{higher-order logic}, which contain quantifiers over the arbitrary nested sets, or \textit{type theory}, which assigns a type for every expression in the formal language.

Let $\Phi$ be a set of formulae. Initially, it consists of only \textit{hypotheses}, a priori true formulae, which are claimed to be already proved. The notation $\Phi \vdash \phi$ means that the formula $\phi$ is \textit{provable} from $\Phi$, if there exists a proof that infers $\phi$ from $\Phi$. The formula which is provable without additional premises (i.e. $\emptyset \vdash \phi$) is called \textit{tautology} and denoted as $ \vdash \phi $. The formula is called \textit{contradiction} if $\vdash \neg \phi$. Obviously, all contradictions are equivalent in one formal system, hence they are denoted as $\bot$.

The formal system described above is called \textit{the Hilbert proof system}, it uses reasoning from \textit{truth} statements, in contrast to \textit{natural deduction systems} that use reasoning from \textit{assumptions}. Although the difference between these two formal systems seems to be subtle, the latter can be used more as framework, allowing to build new systems on the logical base of pre-defined premises and formal proof rules. % AUTHOR'S THOUGHTS, UNVERIFIED

\subsection{Properties of Formal System}

Let $U$ be a set of all possible formulae, let $\Gamma = \ <A, V, \Omega, R>$ be a formal system with set of axioms $A$, set of propositional variables $V$, set of logical operators $\Omega$, and set of inference rules $R$. Then $\Gamma$ is called:
\begin{itemize}
	\itemsep0em
	\item \textit{consistent}, if both formula and its negation can not be proved in the system: \\
		$\nexists \phi \in \Gamma: \ \Gamma \vdash \phi \land \Gamma \vdash \neg \phi  \ \Leftrightarrow \ \Gamma \nvdash \bot$;
	\item \textit{complete}, if all true statements can be inferred: \\
		$\forall \phi \in U: \ A \vdash \phi \lor A \vdash \neg \phi$ ;
	\item \textit{independent}, if no axiom can be inferred from another: \\
		$\not \exists a \in A: \ A \vdash a$.
\end{itemize}

In 1931, Kurt Gödel proved his first incompleteness theorem which states that any consistent formal system is incomplete. Later, in 1936, Alfred Tarski extended this result by proving his Undefinability theorem, which states that the concept of truth cannot be defined in a formal system. % originally: in arithmetic. Does that make sense?
In that case, modern tools, such as Coq, often restrict propositions to be either provable or unprovable, rather than true or false.


% TODO
// TODO -- finish it


Note, that the first-order logic is \textit{undecidable}, so that there does not exist a decision algorithm which is sound, complete and terminating [TODO: REFERENCE]. % TODO <-- 


\subsection{Lambda-calculus}

$\lambda$-\textit{calculus} is a universal computation model invented by Alonzo Church in 1930s as a model for formalising the concept of effective computability.  This formalism provides solid theoretical foundation for the family of functional programming languages~\cite{Roj15}. In $\lambda$-calculus, functions are first-order objects, which means functions can be applied as arguments to other functions.

The central concept in $\lambda$-calculus is an \textit{expression}, which can be defined as a subject for application the rewriting rules~\cite{Bar88}. The basic rewriting rules of $\lambda$-calculus are listed below:

\begin{itemize}
\itemsep0em
	\item Application:
	$f a$ is the call of function $f$ with argument $a$
	
	\item Abstraction:
	$\lambda x.t[x]$ is the function with formal parameter x and body $t[x]$
	
	\item Computation:
	Replace formal parameter by actual argument ($\beta$-\textit{reduction}): \\
	$(\lambda x.t[x]) a \rightarrow_{\beta} t[x:=a]$
\end{itemize}

$\lambda$-calculus described above is called the \textit{type-free} $\lambda$-calculus. The more strong calculi can be constructed by using the types of expressions to the system, for which some useful properties can be proven (e.g., termination or memory safety)~\cite{Bar13}.

\subsection{Type Systems}

A \textit{type} is a collection of elements. In a type system, each element is associated with a type, which defines a basic structure of it and restricts set of possible operations with the element. This allows to reveal useful properties of the formal system. Therefore, type theory serves as an alternative to the classic set theory~\cite{Tho91}.
% TODO: remove notation below if not used.
In our notation, the $a =_{\tau} b$ means that $a$ equals $b$ and both of them are of type $\tau$. This notation is used for convenience to encode information about type to equality.

The function that builds a new type from another is called \textit{type constructor}. Such functions have been used long before type theories had been constructed formally, even in the~19th~century Giuseppe Peano used type constructor $S$ called the \textit{successor} function, along with zero element 0, to axiomatise natural number arithmetic. Thus, number 3 can be constructed as $S(S(S(0))))$.


\subsubsection{Simple Type Theory}
%In the context of current paper, it is useful to describe 
The type can be defined declaratively, by assigning a label to set of values. Such types are called \textit{simple types}, they can be useful to avoid some paradoxes of set theory, e.g., separating sets of individuals and sets of sets allows to avoid famous Russel's paradox~\cite{Irv95}. Simple type theory can extend $\lambda$-calculus to a Higher-order logic through connection between formulae and expressions of type Boolean~\cite{Paulson90}.

% TODO: // == Pure Type System ?
% https://www.cl.cam.ac.uk/teaching/1516/Types/lectures/lecture-9.pdf
% https://en.wikiversity.org/wiki/Foundations_of_Functional_Programming/Pure_type_systems
% http://www4.di.uminho.pt/~mjf/pub/SFV-CIC-2up.pd


% TODO: // == Polymorphic Type Theory ?
%\subsubsection{Polymorphic Type Theory}
% //not needed
% --
% \subsubsection{System F}
% second-order lambda calculus, is a typed lambda calculus that differs from the simply typed lambda calculus by the introduction of a mechanism of universal quantification over types
% //not needed


\subsubsection{Martin-Löf Type Theory}
The Martin-Löf type theory, also known as the \textit{Intuitionistic type theory}, is based on the principles of mathematical constructivism, that require explicit definition of the way of "constructing" an object in order to prove its existence. Therefore, an important place in intuitionistic type theory is held by the \textit{inductive types}, which were constructed recursively using a basic type (zero) and successor function which defines "next" element.

The Intuitionistic type theory also uses a wide class of \textit{dependent types}, whose definition depends on a value. For instance, the $n$-ary tuple is a dependent type that is defined by the value of~$n$. However, the type checking for such a system is an undecidable problem since determining of the equality of two arbitrary dependent types turns to be tantamount to a problem of inducing the equivalence of two non-trivial programs (which is undecidable in general case according to the Rice's theorem~\cite{Rice53}).

%A language with dependent types may include references to programs inside of types. For instance, the type of an array might include a program expression giving the size of the array, making it possible to verify absence of out-of-bounds accesses statically. Dependent types can go even further than this, effectively capturing any correctness property in a type. PVS’s dependent types are much more general, but they are squeezed inside the single mechanism of subset types, where a normal type is refined by attaching a predicate over its elements. Each member of the subset type is an element of the base type that satisfies the predicate. 


\subsubsection{Calculus of Constructions}
% TODO: figure out how this implies to PTS - Pure Type Systems

Another important constructive type theory is the Calculus of Constructions~(CoC) developed by Thierry~Coquand and Gérard~Huet in 1985~\cite{Coq85}. It represents a natural deduction system which incorporates dependent types, polymorphism and type constructors.

% TODO
// TODO: MORE DEFINITIONS HERE
% see also the Coq documentation: https://coq.inria.fr/refman/cic.html#conv-rules

%The Calculus of Construction can be considered as an extension of the Curry–Howard isomorphism. % in a way that the latter associates a term in the simply typed lambda calculus with each natural-deduction proof in intuitionistic propositional logic, when the Calculus of Construction extends this isomorphism to proofs in the full intuitionistic predicate calculus, which includes proofs of quantified statements (which are also called "propositions").

The CoC has \text{strong normalisation property}, which means that every sequence of inference eventually terminates with an irreducible normal form. This property does not allow to define infinitely recursive structures and functions. % TODO: check whether one can say that with respect to any formal system, not only to an abstract rewriting system

Inference rules for the Calculus of Constructions:
\begin{enumerate}
	\item ${\displaystyle {{} \over {}\Gamma \vdash P:T}}$
	\item ${\displaystyle {\Gamma \vdash A:K \over {\Gamma ,x:A\vdash x:A}}}$
	\item ${\displaystyle {\Gamma ,x:A\vdash B:K\qquad \Gamma ,x:A\vdash N:B \over {\Gamma \vdash (\lambda x:A.N):(\forall x:A.B):K}}}$
	\item ${\displaystyle {\Gamma \vdash M:(\forall x:A.B)\qquad \Gamma \vdash N:A \over {\Gamma \vdash MN:B[x:=N]}}}$
	\item ${\displaystyle {\Gamma \vdash M:A\qquad A=_{\beta }B\qquad B:K \over {\Gamma \vdash M:B}}}$ % \over {\Gamma \vdash M : B}}
\end{enumerate}

// TODO: add explanations to the inference rules or delete them

In 1990, Christine Paulin proposed the \textit{Calculus of Inductive Constructions}~(CIC) as an extension of Calculus of Construction by adding the Martin-Löf's primitive inductive definitions in order to perform efficient computation of the functions over inductive data types~\cite{Pau2015}. This formalism lies behind the Coq proof assistant.

%----------------------------------------------------------


\subsection{Curry-Howard isomorphism}
% TODO
// TODO -- this is the most delicious idea among those described in this paper...

"proofs are programs"
% http://perso.ens-lyon.fr/damien.pous/ejcp13/slides.pdf slide 9 - draw the same pic
% +show correspondence in two-column view
bla-bla correspondence, isomorphism, very interesting thing...
% 1934–1969

%============================================================

% Probably exclude this paragraph.

%\section{Methods for automated reasoning}
%\label{sec:auto_reasoning}

%techniques in common words (and in introduced previously notation), e.g.: 
%\begin{itemize}
%\itemsep0em
%	\item Clause rewriting
%		Simplification - The concept of (conditional) term rewriting is introduced and its realization as the proof method simp is explained. (from http://isabelle.in.tum.de/coursematerial/PSV2009-1/)
		
%	\item Resolution
%	\item Sequent Deduction
%	\item Natural Deduction
%	\item The Matrix Connection Method
%	\item Term Rewriting (+lambda calculus)
%	\item Mathematical Induction
%\end{itemize}


%============================================================


\section{Comparison of some theorem provers}
\label{sec:comparison}

We have chosen for our comparison two automated proof assistants, \textit{Coq} and \textit{Isabelle/HOL}\footnote{Roughly speaking, Isabelle is a core for an automated theorem proving which supports multiple logical theories: Higher-Order Logic (HOL), first-order logic theories such as Zermelo-Fraenkel Set Theory (ZF), Classical Computational Logic (CCL), etc. In this paper, we consider the Isabelle/HOL as the startpoint for exploring the power of this proof assistant.} as they both are widely used tools for theorem proving.

%TODO: intuitionistic logic VS classical logic:
"There are theorems of CPC that are unprovable in IPC, but not vice versa, so the latter logic is strictly weaker. "
%source: https://books.google.fi/books?id=GEilBAAAQBAJ&pg=PA116&lpg=PA116&dq=cpc+ipc+logic&source=bl&ots=PhdmaUzjhe&sig=taRlu2rx6J3NyeD-flYE0xpOK8I&hl=fi&sa=X&ved=0ahUKEwitxey59tzXAhWmDZoKHbbZA3YQ6AEINjAB#v=onepage&q=cpc%20ipc%20logic&f=false

%------------------------------------------------------------

\subsection{The Coq theorem prover}
\label{sec:prover_coq}

Coq is a formal proof assistant system which has been developed at INRIA (Paris, France) since 1984. As a proof assistant system, Coq offers multiple interactive proof methods called \textit{tactics} and decision algorithms for letting the user define new proof methods. A key feature of Coq is a capability of extraction of the verified program (in OCaml, Haskell or Scheme) from the constructive proof of its formal specification~\cite{tool_Coq}. This facilitates using Coq as a tool for software verification.

During the proof process, Coq remembers its state, a set of \textit{premises}, which are considered to be true, and set of \textit{goals} (or subgoals), the statements to be proved. The proof consists of sequence of commands describing which tactic Coq should apply. Tactic may be thought as a pattern of reasoning, it can be already proved rule of inference, removing a hypothesis or introducing of a variable, application of the reasoning principle (such as induction), etc. Coq can be asked to try to find appropriate tactic from its collection in the mode \textit{auto}.

In proofs, Coq combines two languages: \textit{Gallina}, a purely functional programming language, and \textit{Ltac}, a procedural language for manipulating the proof process. A statement for proof and structures it relies on are written in Gallina, and the tactics (inference rules) are written in Ltac. These tactics  // TODO !!! % TODO: describe tactics


// "Coq's built-in logic is very small: the only primitives are Inductive definitions, universal quantification (forall), and implication (->), while all the other familiar logical connectives — conjunction, disjunction, negation, existential quantification, even equality — can be encoded using just these."
%// https://softwarefoundations.cis.upenn.edu/sf-3.2/Logic.html

// In Coq, "Implications are functions"

// The \texttt{False} in Coq is a type without a constructor:
	"Inductive False : Prop := ." 
"Intuition: False is a proposition for which there is no way to give evidence."
=> show the proof of 'ex falso quodlibet' ?

"Inductive True : Prop := I : True." ("a proposition for which it is trivial to give evidence" => always true proposition)
%(https://softwarefoundations.cis.upenn.edu/sf-3.2/Logic.html)



// ?else?

%http://www.seas.upenn.edu/~cis500/current/sf/lf-current/Basics.html#lab30


%------------------------------------------------------------

\subsection{The Isabelle/HOL theorem prover}
\label{sec:prover_isabelle}

Isabelle was developed by Larry Paulson in Technical University of Munich as a successor of HOL theorem prover~\cite{tool_HOL}. Isabelle was released for the first time in 1986 (two years after the Coq's first release). It was built in a modular manner, i.e., it has relatively small core, which can be extended by numerous basic theories that describe logic behind Isabelle. In particular, the theory of higher-order logic is implemented as Isabelle/HOL, and it is commonly used because of its expressivity and relative conciseness. Similarly to Coq, it combines several languages in its proofs: HOL as a functional programming language (which must be always in quotes), and the language for describing procedures for manipulating the proof. Unlike Coq, Isabelle supports more expressive style of proofs written in a declarative fashion in language Isar.

// IDE allows to randomly pick jump to any place in the syntax tree of the proof and view the state (in spite of Coq, where only the forward-backward operations are allowed).

% citing: """Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification."""

// some words on termination checks in Isabelle (unlike Coq)
%Termination: "The method lexicographic_order is the default method for termination proofs.
% https://isabelle.in.tum.de/doc/functions.pdf page 4

// ?else?

%------------------------------------------------------------


\subsection{Common features}

In general, both Coq and Isabelle work in a similar way: given definition of a statement, they can either verify already written proof, or help user to develop such proof in an interactive fashion, so that the invalid proofs cannot be accepted. Both systems have rather large libraries with considerable amount of already proven lemmas and theorems; in addition, they can be used as functional programming languages as they allow to construct new data types and recursive functions, they have pattern matching, type inference and other features inherent for functional languages. Both tools are being actively developed: on the moment of writing this paper (autumn 2017), the latest versions were Coq 8.7.0 (stable) and Isabelle2017, both released in October 2017.


Nonetheless, the key difference between these two systems is that they are based on different logical theories. Isabelle/HOL exploits higher order logic along with decidable non-dependent types, while Coq is based on Calculus of Inductive Constructions, which uses inductive and dependent types and represents an implementation of intuitionistic logic.


Since their first release, both Coq and Isabelle have already been used to formalize enormous amount of mathematical theorems, including those which have very large or even controversial proof, such as Four colour theorem (2004), Lax-Milgram theorem (2017), and other important theorems~\cite{Wiedijk100}. Moreover, the theorem provers have been successfully used for testing and verifying of software programs, including the general-purpose operating system kernel~seL4~(2009)~\cite{Klein09}, the C~standard~(2015)~\cite{Krebbers15}, and others.


Both Coq and Isabelle have their own Integrated Development Environment (IDE) to work in (gtk-based CoqIDE and jEdit Prover IDE, respectively). In general, both native IDEs of these theorem provers provide the facility for interactive executing scripts step-by-step while preserving the state of proof (\textit{environment}), which for each step describes the set of premises along with already proved statements (\textit{context}) and the set of statements to be proven (\textit{goals}). However, Isabelle's native IDE allows to change the proof state arbitrarily, in contrast to the CoqIDE, which provides only the capability of switching the proof state to the next or previous statement only. Alternatively, both considering theorem provers have numerous of plugins for many popular IDEs, for instance, the Proof General~\cite{tool_PG} is a plugin for Emacs, which supports numerous proof assistants. During the work on this paper, we used the native IDEs of each proof assistant in order to minimize the impact of third-party tools to our research.


%------------------------------------------------------------

\subsection{First-order Logic Proofs}

Figure~\ref{Coq:DeMorgan_Prop} shows the proof of De Morgan's law in Coq system. The law statement is being proved for all propositions of type \texttt{Prop}  <which is ...> ... . For arguments of type \texttt{bool} the proof is trivial.

\begin{lstlisting}[caption={Definition of basic propositional terms in Coq}]
Check False. (* output: Prop : Type *)
Print False. (* output: Inductive False : Prop :=  *)
Print True.  (* output: Inductive True : Prop :=  I : True *)
\end{lstlisting}

\begin{lstlisting}[caption={Proof of propositional logic tautology in Coq: the de Morgan's law for propositions},label={Coq:DeMorgan_Prop}]

Theorem DeMorgan : forall P Q : Prop,
    ~P /\ ~Q <-> ~(P \/ Q).
Proof.
    intros P Q. unfold iff.
    split.
    - intros H_and_not H_or.
      destruct H_and_not as [H_not_P H_not_Q].
      destruct H_or as [H_P | H_Q].
      + apply H_not_P. assumption.
      + apply H_not_Q. assumption.
    - intros H_not_or. unfold not. constructor.
      + intro H_P. apply H_not_or. left. apply H_P.
      + intro H_Q. apply H_not_or. right. apply H_Q.
Qed.
\end{lstlisting}

<tauto - the tactic to automatically prove propositional tautologies (need definition of tautology)>
\begin{lstlisting}
Theorem DeMorgan : forall P Q : Prop, 
    ~P /\ ~Q <-> ~(P \/ Q).
Proof.
    tauto.
Qed.
\end{lstlisting}

<but Coq's logic does not include the axiom of excluded middle:>
% from here https://coq.inria.fr/tutorial/1-basic-predicate-calculus
\begin{lstlisting}
Lemma ExcludedMiddle: forall P, 
    P \/ ~P.
Proof.
    try tauto.  (* tauto fails in Coq's intuitionistic logic *)
Abort.
\end{lstlisting}

<idea: Assuming NOT(A OR NOT A), you first prove ~A, then find a contradiction.>
% source: http://coq-club.inria.narkive.com/jqsPmOBk/is-a-prop-a-a-provable-in-coq
% from here https://stackoverflow.com/a/32813110 
% TODO: Make a reference to that answer or to the mailing list. OR BETTER DIRECTLY TO GLIVENKO'S THM!!! double-negation translation
%"If φ is a propositional formula, then φ is a classical tautology if and only if ¬¬φ is an intuitionistic tautology."

\begin{lstlisting}
Lemma DoubleNegatedExcludedMiddle: forall P : Prop, 
    ~~(P \/ ~P).
Proof.
    unfold not. 
    intros P f.
    apply f.
    right. 
    intro P_holds.
    apply f.
    left.
    exact P_holds.
Qed.
\end{lstlisting}

<here bool is inductively defined as a \texttt{Set} => can use destruct, which expands the definition of inductive type>
\begin{lstlisting}[caption={Propositional logic proof: de Morgan's law for booleans},label={Coq:DeMorgan_bool}]
Check bool.  (* output: bool : Set *)
Check false. (* output: false : bool *)
Print bool.  (* output: Inductive bool : Set :=  true : bool | false : bool *)

Notation "a || b" := (orb a b).
Notation "a && b" := (andb a b).

Theorem DeMorgan_bool : forall a b: bool,
    negb (a || b) = ((negb a) && (negb b)).
Proof.
    intros a b.
    destruct a; simpl; reflexivity.
Qed.
\end{lstlisting}




<non-provable stmt 2**sqrt(2) irrational....>

<non-provable formule de Peirce is insoluble
P,Q: Prop |-? ((P->Q)->P)->P
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .


%............................................................
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
%............................................................

%............................................................
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
%............................................................

%............................................................
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
%............................................................

%............................................................
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
%............................................................

%............................................................
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
%............................................................

%............................................................
% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
%............................................................







% also see https://gist.github.com/bbc2/092e224a78f17ed9c437


\begin{lstlisting}
Inductive nat : Type :=
	| O : nat
	| S : nat -> nat.
\end{lstlisting}

\begin{lstlisting}[caption={Recursive function definition: factorial}]
... example here with 'Fixpoint' and 'Inductive'
...//fix x (v : V) : X := t Recursive function.
\end{lstlisting}
// "Syntactic restriction on recursive calls on term":
// Coq doesn't allow to define recursive functions without decreasing argument => always terminates

\begin{lstlisting}[caption={Non-recursive function definition: factorial}]
//cheatsheet //fun x : X => t Non-recursive function.
...
\end{lstlisting}

\begin{lstlisting}[caption={Inductive data type definition: ???}]
...
...
\end{lstlisting}

% see http://perso.ens-lyon.fr/jeremy.ledent/coq/coq_tutorial_solutions.v
	\begin{lstlisting}[caption={Propositional logic proof: de Morgan's law}]
Lemma DeMorgan_1 : (forall A B : Prop, ~(A /\ B) -> ~A \/ ~B).
Proof.
intros.
...
Qed.
\end{lstlisting}

// ... A practical example: proof of correctness of an algorithm which sums n first members of arithmetic progression using formula $S_{n} = { {\frac {2 a_{1} + d (n - 1)}{2} \cdot n}}$ through direct counting of this sum: $S_{n} = \sum\limits_{k=0}^{n-1} (a_{1} + d \cdot k)$.
%https://coq.inria.fr/library/Coq.Logic.Classical_Pred_Type.html
%, label={lst:example1}]
\begin{lstlisting}[caption={First-order logic proof: formula of the sum of n first members of arithmetic progression}]
Lemma ... ... 
Proof.
...
...
...
Qed.
\end{lstlisting}

% proof of simple propositional formula
%Theorem forward_small : (forall A B : Prop, A -> (A->B) -> B).
%Proof.
%intros A.
%intros B.
%intros proof_of_A.
%intros A_implies_B.
%pose (proof_of_B := A_implies_B proof_of_A).
%exact proof_of_B.
%Qed.


\begin{lstlisting}[caption={Recursive function definition: factorial}]
...
...
\end{lstlisting}

\begin{lstlisting}[caption={Non-recursive function definition: factorial}]
...
...
\end{lstlisting}

\begin{lstlisting}[caption={Inductive data type definition: list}]
...
...
\end{lstlisting}

// Isabelle's feature: non-constructive logic!
%- иллюстрация доказательства в классической логике, от противного. Теор Кантора
%https://isabelle.in.tum.de/doc/prog-prove.pdf стр 42.
\begin{lstlisting}[caption={Propositional logic proof to the contrary}]
Lemma DeMorgan_1 : (forall A B : Prop, ~(A /\ B) -> ~A \/ ~B).
Proof.
intros.
...
Qed.
\end{lstlisting}

// Useful features: automatically find a model (SAT)
\begin{lstlisting}[caption={Isabelle as an SAT solver}]
... nitpick - finds a model
...
\end{lstlisting}

%// Sometimes Isabelle advices how it is possible to prove a statement more easily
%иногда Подсказывает, как можно проще доказать
%напр, для ассоциативности дизъюнкции, lemma disj_swap: "P ∨ Q ⟹ Q ∨ P"
%proof (prove)
%goal (1 subgoal):
%1. P ∨ Q ⟹ Q ∨ P 
%Auto solve_direct: the current goal can be solved directly with
%Meson.disj_comm: ?P ∨ ?Q ⟹ ?Q ∨ ?P
%// overview good at: https://pdfs.semanticscholar.org/95bf/a1bf0cbf5ae2c2a70daa13d4966143bd96f8.pdf




// ... [Also] A practical example: proof of correctness of an algorithm which sums n first members of arithmetic progression using formula $S_{n} = { {\frac {2 a_{1} + d (n - 1)}{2} \cdot n}}$ through direct counting of this sum: $S_{n} = \sum\limits_{k=0}^{n-1} (a_{1} + d \cdot k)$.
%https://coq.inria.fr/library/Coq.Logic.Classical_Pred_Type.html
%, label={lst:example1}]
\begin{lstlisting}[caption={First-order logic proof: formula of the sum of n first members of arithmetic progression}]
Lemma ... ... 
Proof.
...
...
...
Qed.
\end{lstlisting}


%------------------------------------------------------------


% see https://people.cs.kuleuven.be/~bart.jacobs/coq-essence.pdf, 11 Coq versus classical logic

\subsection{Results of comparison}
\label{sec:joint_comparison}

//TODO: perhaps in table:
\begin{itemize}
	\itemsep0em
	\item expressiveness of logic used
	\item time of proving
	\item num of supporting theories
	\item set of techniques to prove automatically
	\item Volume of proof (as text)
	\item num of user interaction steps
	\item usability
	\item etc ...
\end{itemize}

%============================================================


\section{Future work}
\label{sec:future_work}

// TODO (Paragraph is still in progress)

< in future, we want to apply this survey to software verification >

%============================================================


\bibliographystyle{ieeetr}
\bibliography{cs-seminar}

\end{document}