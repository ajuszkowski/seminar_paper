\documentclass[article]{aaltoseries}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}  % remove spaces before enumerations and lists
\usepackage{url}
%\usepackage{inconsolata}  % for mono font
\usepackage{amssymb}  % for negated \vdash
\usepackage{amsmath}  % for multi-line equations
\begin{document}

%=========================================================

\title{Comparison of Theorem Provers}

\author{Artem Yushkovskiy
\\\textnormal{\texttt{artem.yushkovskiy@aalto.fi}}}

\affiliation{\textbf{Tutor}: Stavros Tripakis}

\maketitle

%==========================================================

\begin{abstract}
One of the useful applications of mathematical logic theory is Automated theorem proving. This is a set of techniques that allow one to verify mathematical statements mechanically using logical reasoning. Although it can be used to solve engineering problems as well, for instance, to prove security properties for a software system or an algorithm.
% TODO: probably drop out the sentence below ("i'm not sure in what sense theorem proving is part of AI, but i guess you'll describe this below")
Furthermore, automated theorem proving is an essential part of the Artificial Intelligence theory, which is highly evolving in recent years.
%continue...
This paper compares two widespread tools for automated theorem proving, Coq~\cite{tool_Coq} and Isabelle~\cite{tool_Isabelle}, with respect to the power of expressiveness and usability. For this reason, it firstly gives a brief introduction to the bases of formal systems and automated deduction theory, its main problems and challenges.

\vspace{3mm}
\noindent KEYWORDS: logic, formal method, proof theory, automated theorem prover, Coq, Isabelle.
	
\end{abstract}


%============================================================

\section{Introduction}

Nowadays, the search for foundations of mathematics has become one of the key questions in philosophy of mathematics, which eventually have an impact on numerous problems in modern life. Basically, this search has led to the development of \textit{formal approach}, a methodology for manipulating the abstract essences according basic rules in a verifiable way. In other words, it is possible to follow the sequence of such manipulations in order to check the validity of each statement and, as a result, of a system at whole. Moreover, automating such a verification process can significantly increase reliability of formal models and systems based on them.

At present, a large number of tools have been developed to automate this process. Generally, these tools can be divided into two broad classes. 

The first class contains tools pursuing the aim of validating the input statement (\textit{theorem}) with respect to the sequence of inference transitions (user-defined \textit{proof}) according to set of inference rules. Such tools are sometimes called \textit{proof assistants} since they may require some user interaction and may help user to develop new proofs as well. The tools \textit{Isabelle}~\cite{tool_Isabelle}, \textit{Coq}~\cite{tool_Coq}, \textit{PVS}~\cite{tool_Pvs} are well-known examples of such systems, which are commonly used nowadays.

The second class consists of tools that automatically \textit{discover} the formal proof, which can rely either on induction, on meta argument, or on higher-order logic. Such tools are often called \textit{automated theorem provers} so that they apply techniques of automated reasoning to find the proof. The systems \textit{Otter}~\cite{tool_Otter} and \textit{ACL2}~\cite{tool_Acl} are commonly known examples of such tools.

In this paper only systems of the first class were considered, since they can be sufficiently applied in model checking and software verification. 


%------------------------------------------------------------

\subsection{Related work}
A considerably extensive survey on theorem provers has been presented by F.~Wiedijk~\cite{Wie03}, where fifteen 'state-of-the-art' systems for the formalization of mathematics were compared against various properties, in particular size of library with already proved lemmas, strength and expressiveness of underlying logic, size of proofs (the de Bruijn criterion) and level of automation (the Poincaré principle). As the continuation of that work, we propose more deep comparison of two aforementioned theorem provers -- Coq and Isabelle -- with respect to criteria s.a. expressiveness, computation power and usability.

%------------------------------------------------------------

\subsection{Outline}
This paper is organised as follows.
Section~\ref{sec:formal_theory} provides definition, basic properties and theoretical limitations of the formal systems. Section~\ref{sec:auto_reasoning} covers general methods for automated reasoning. Section~\ref{sec:applications} enumerates possible application areas for automated theorem provers. Finally, Section~\ref{sec:comparison} presents target comparison properties and the comparison itself.

%============================================================

\section{Axiomatisation and Formal Systems}
\label{sec:formal_theory}

The formal approach appeared in the beginning of previous century when mathematics experienced deep fundamental crisis caused by the need for a formal definition of the very basis. At that time, multiple paradoxes in several fields of mathematics have been discovered. Moreover, the completely new theories appeared just by modification of the set of axioms, e.g., reducing the parallel postulate of Euclidean geometry has lead to completely different non-Euclidian geometries s.a. Lobachevsky's hyperbolic geometry or Riemman's elliptic geometry, that eventually have a large number of applications in both natural sciences and engineering.

\subsection{Definitions}
\label{sec:definitions}

%\texttt{Definition.}
The \textit{formal proof} of the formula $\phi$ is a finite sequence of statements $ ( \psi_i )_{i=1}^{n} $, where each $\psi_i$ is either an axiom $A_i$, or a formula inferred from the subset $\{ \psi_k \}_{k=1}^{i-1}$ of previously derived formulae according the \textit{rules of inference}. \textit{An axiom} $A_i \in A$ is a statement evidently claimed to be true. \textit{A logical inference} is a transfer from one statement (\textit{premise}) to another (\textit{consequence}), which preserve truth. In formal logic, inference is based entirely on the structure of those statements, thereby, the result formal system represents the abstract model describing part of real world.
%The set of axioms and rules of logical inference form the \textit{logical system}.

The formulae consists of \textit{propositional variables}, connected with \textit{logical operators} according to rules, defined by a formal language. The formulae, which satisfy such rules, are called \textit{well-formed} (wff). The propositional variable is an atomic formula which can be either true or false. The logical operator is a symbol in formal language that transforms one wff to another.

Let $\Gamma$ be a set of formulae. Initially, it consists of only \textit{hypotheses}, a priori true formulae, which are claimed to be already proved. The notation $\Gamma \vdash \phi$ means that the formula $\phi$ is \textit{provable} from $\Gamma$, if there exists a proof that infers $\phi$ from $\Gamma$. The formula which is provable without additional premises (i.e. $\emptyset \vdash \phi$) is called \textit{tautology} and denoted as $ \vdash \phi $. The formula is called \textit{contradiction} if $\vdash \neg \phi$. Obviously, all contradictions are equivalent in one formal system, hence they are denoted as $\bot$.

% TODO: \subsection{ ? }

Let $U$ be a set of all possible formulae, let $\Delta = \ <A, V, \Omega, R>$ be a formal system with set of axioms $A$, set of propositional variables $V$, set of logical operators $\Omega$, and set of propositional variables and set of inference rules $R$. Then $\Delta$ is called:
\begin{itemize}
	\itemsep0em
	\item \textit{consistent}, if no formula of the system contradicts another: \\
		$\nexists \phi \in \Delta: \ \Delta \vdash \phi \land \Delta \vdash \neg \phi  \ \Leftrightarrow \ \Delta \nvdash \bot$;
	\item \textit{complete}, if all truth statements can be inferred: \\
		$\forall \phi \in U: \ A \vdash \phi \lor A \vdash \neg \phi$ ;
	\item \textit{independent}, if no axiom can be inferred from another: \\
		$\exists a \in A: \ A \vdash a$.
\end{itemize}


If the propositional variables have no restrictions on their form (i.e. they are 0-arity predicates), such logic is called \textit{propositional logic}. However, if these variables are quantified on some sets, such logic is called \textit{first-order} or \textit{predicate logic}. Commonly, first-order logic has two quantifiers, the universal quantifier '$\forall$' (means "for every"), and the existential quantifier '$\exists$' (means "there exists"). Thereafter, the \textit{second-order logic} extends first-order logic by adding quantifiers over second-order objects -- relations defining the sets of sets. In turn, it can be extended by the \textit{higher-order logic}, which contain quantifiers over the arbitrary nested sets, or \textit{type theory}, which assigns a type for every term in .

Although the higher-order logics have stronger semantics than lower-order logics, they have 

Note, that the first-order logic is \textit{undecidable}, so that there does not exist a decision algorithm which is sound, complete and terminating.

%\begin{itemize}
%\itemsep0em
%	\item what the logical system is (formally: set of axioms, inference rules)
%	\item (?) a brief history of axiomatic approach (Euclid, Hilbert)
%	\item what the truth is: completeness
%	\item intro to set theory (for notation) +Zermelo–Fraenkel set theory (ZFC)
%	\item intro to formal languages
%	\item intro to propositional and 1st ordered logic (introduce notation here. Maybe Higher-Order Logic, Non-classical Logics)
%	\item type systems (+dependent type, where type checking although may be undecidable, but it verifies the correctness of ), Nominal vs. structural type system. \textbf{Curry–Howard correspondence} (the direct relationship between computer programs and mathematical proofs)
%	\item else?
%\end{itemize}

%Let $A, B, C, ...$ be \textit{prepositions}, i.e., statements which preserve facts on real world.  
%Let $\phi$ be a well-formed formula (i.e. a syntactically valid statement) $\Gamma$ be a set of formulas 

% // two words about intuitionism, if needed (in Coq, par exemple)


%============================================================

\section{Methods for automated reasoning}
\label{sec:auto_reasoning}

// TODO (Paragraph is still in progress)

techniques in common words (and in introduced previously notation), e.g.: 
\begin{itemize}
\itemsep0em
	\item Clause rewriting
	\item Resolution
	\item Sequent Deduction
	\item Natural Deduction
	\item The Matrix Connection Method
	\item Term Rewriting (+lambda calculus)
	\item Mathematical Induction
\end{itemize}


% perhaps separate into subsections

%============================================================

\section{Some applications of theorem provers}
\label{sec:applications}

// TODO (Paragraph is still in progress) 

Describe possible applications of formal methods:
\begin{enumerate}
	\itemsep0em
	\item Interactive theorem proving: construct a formal axiomatic proof of correctness, 
	\item verifying that a mathematical statement is true.
	\item verifying that a circuit description, an algorithm, or a network or security protocol meets its specification:
	\begin{itemize}
		\item program verification (first-order logic), 
		\item distributed and concurrent systems (modal and temporal logics), 
		\item program specification (intuitionistic logic),
		\item Model checking: reduce to a finite state space, and test exhaustively.
		\item hardware verification (higher-order logic), 
		\item logic programming (Horn logic), 
		\item and so on.
	\end{itemize}
\end{enumerate}

%============================================================

\section{Comparison of some theorem provers}
\label{sec:comparison}

//TODO (Paragraph is still in progress) 

(in two words: here we consider Coq and Isabelle, bla-bla)

%MOCK from "Certified Programming with Dependent Types" by Adam Chlipala.
%/* ACL2 is notable in this field for having only a first-order language at its foundation. That is, you cannot work with functions over functions and all those other treats of functional programming. By giving up this facility, ACL2 can make broader assumptions about how well its proof automation will work, but we can generally recover the same advantages in other proof assistants when we happen to be programming in first-order fragments

%Isabelle/HOL and Coq both support coding new proof manipulations in ML in ways that cannot lead to the acceptance of invalid proofs. Additionally, Coq includes a domain-specific language for coding decision procedures in normal Coq source code, with no need to break out into ML.

%A language with dependent types may include references to programs inside of types. For instance, the type of an array might include a program expression giving the size of the array, making it possible to verify absence of out-of-bounds accesses statically. Dependent types can go even further than this, effectively capturing any correctness property in a type. PVS’s dependent types are much more general, but they are squeezed inside the single mechanism of subset types, where a normal type is refined by attaching a predicate over its elements. Each member of the subset type is an element of the base type that satisfies the predicate. 
%*/

%------------------------------------------------------------

\subsection{The Coq theorem prover}
\label{sec:prover_coq}

// TODO (Paragraph is still in progress)

Coq is a formal proof assistant system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs~\cite{tool_Coq}. Coq uses the Calculus of Construction, a higher-order formalism for constructive proofs in natural deduction style, developed by Thierry Coquand~\cite{Coq86}. 
The Calculus of Construction can be considered as an extension of the Curry–Howard isomorphism. % in a way that the latter associates a term in the simply typed lambda calculus with each natural-deduction proof in intuitionistic propositional logic, when the Calculus of Construction extends this isomorphism to proofs in the full intuitionistic predicate calculus, which includes proofs of quantified statements (which are also called "propositions").

(add some core features of Coq ...)

(Coq has been used to formalize ...)

%------------------------------------------------------------

\subsection{The Isabelle theorem prover}
\label{sec:prover_isabelle}

// TODO (Paragraph is still in progress)

The Isabelle is an interactive theorem prover, which relies on higher-order logic. It allows mathematical formulas to be expressed in a formal language and provides tools for proving those formulas in a logical calculus~\cite{tool_Isabelle}. Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification.

(add some core features of Isabelle ...)

(Isabelle has been used to formalize ...)

%MOCK from wiki:
%/* it is based on a small logical core to ease logical correctness. Isabelle is generic: it provides a meta-logic (a weak type theory), which is used to encode object logics like first-order logic (FOL), higher-order logic (HOL) or Zermelo–Fraenkel set theory (ZFC). Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification. Though interactive, Isabelle also features efficient automatic reasoning tools, such as a term rewriting engine and a tableaux prover, as well as various decision procedures. Isabelle has been used to formalize numerous theorems from mathematics and computer science, like Gödel's completeness theorem, Gödel's theorem about the consistency of the axiom of choice, the prime number theorem, correctness of security protocols, and properties of programming language semantics. The Isabelle theorem prover is free software, released under the revised BSD license.
% */

%------------------------------------------------------------

\subsection{Joint comparison}
\label{sec:joint_comparison}

//TODO: in table:
\begin{itemize}
	\itemsep0em
	\item expressiveness of logic used
	\item time of proving
	\item num of supporting theories
	\item set of techniques to prove automatically
	\item Volume of proof (as text)
	\item num of user interaction steps
	\item usability
	\item etc ...
\end{itemize}

%============================================================

\section{Results}
\label{sec:results}

// TODO (Paragraph is still in progress)
% Pr Tripakis' note: "i think this version can be merged into section 7, perhaps as its last subsection, 7.x"
conclusion of comparison

%============================================================

\section{Future work}
\label{sec:future_work}

// TODO (Paragraph is still in progress)

< in future, we want to apply this survey to software verification >


%============================================================


\bibliographystyle{ieeetr}
\bibliography{cs-seminar}

\end{document}
