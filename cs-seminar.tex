\documentclass[article]{aaltoseries}
\input{include/cs-seminar.sty}
\usepackage{listings}  % already imported in cs-seminar.sty, here is needed for correct syntax highlighting in TeXstudio.

\begin{document}
%\counterwithin{lstlisting}{section}

%=========================================================

\title{Comparison of Theorem Provers}

\author{Artem Yushkovskiy
\\\textnormal{\texttt{artem.yushkovskiy@aalto.fi}}}

\affiliation{\textbf{Tutor}: Stavros Tripakis}

\maketitle

%==========================================================


\begin{abstract}

The need for formal definition of the very basis of mathematics arose in the last century.
The scale and complexity of mathematics, along with discovered paradoxes, revealed the danger of accumulating errors across theories. Although, according to Gödel's incompleteness theorems, it is not possible to construct a single formal system which will describe all phenomena in the world, being complete and consistent at the same time, that crisis has considerably improved philosophical views on mathematics. 
In addition, it gave rise to rather practical areas of logic, such as the theory of automated theorem proving. This is a set of techniques used to verify mathematical statements mechanically using logical reasoning. Moreover, it can be used to solve complex engineering problems as well, for instance, to prove the security properties of a software system or an algorithm.
This paper compares two widespread tools for automated theorem proving, Coq~\cite{tool_Coq} and Isabelle/HOL~\cite{tool_Isabelle}, with respect to the power of expressiveness and usability. For this reason, it firstly gives a brief introduction to the bases of formal systems and automated deduction theory, its main problems and challenges.

\vspace{3mm}
\noindent KEYWORDS: logic, formal method, proof theory, automated theorem prover, Coq, Isabelle.
	
\end{abstract}

%============================================================


\section{Introduction}

Nowadays, the search for foundations of mathematics has become one of the key questions in philosophy of mathematics, which eventually has an impact on numerous problems in modern life. Basically, this search has led to the development of \textit{formal approach}, a methodology for manipulating the abstract essences according basic rules in a verifiable way. In other words, it is possible to follow the sequence of such manipulations in order to check the validity of each statement and, as a result, of a system at whole. Moreover, automating such a verification process can significantly increase reliability of formal models and systems based on them.

At present, a large number of tools have been developed to automate this process. Generally, these tools can be divided into two broad classes. 

The first class contains tools pursuing the aim of validating the input statement (\textit{theorem}) with respect to the sequence of inference transitions (user-defined \textit{proof}) according to set of inference rules. Such tools are sometimes called \textit{proof assistants}, their purpose is to help users to develop new proofs. The tools \textit{Isabelle}~\cite{tool_Isabelle}, \textit{Coq}~\cite{tool_Coq}, \textit{PVS}~\cite{tool_Pvs} are well-known examples of such systems, which are commonly used in recent years.

The second class consists of tools that automatically \textit{discover} the formal proof, which can rely either on induction, on meta argument, or on higher-order logic. Such tools are often called \textit{automated theorem provers}, they apply techniques of automated logical reasoning to develop the proof. The systems \textit{Otter}~\cite{tool_Otter} and \textit{ACL2}~\cite{tool_Acl} are commonly known examples of such tools.

In this paper, only systems of the first class were considered in order to test the usability of such systems.

%------------------------------------------------------------


\subsection{Related work}
A considerably extensive survey on theorem provers has been presented by F.~Wiedijk~\cite{Wie03}, where fifteen 'state-of-the-art' systems for the formalization of mathematics were compared against various properties, in particular size of library with already proved lemmas, strength and expressiveness of underlying logic, size of proofs (the de Bruijn criterion) and level of automation (the Poincaré principle). We propose more deep comparison of two aforementioned theorem provers -- Coq and Isabelle -- with respect to criteria, such as expressiveness, computation power and usability. Section~\ref{sec:formal_theory} provides definition, basic properties and theoretical limitations of the formal systems, while Section~\ref{sec:comparison} presents target comparison properties and the comparison itself.


%============================================================


\section{Foundations of Formal Approach}
\label{sec:formal_theory}

The formal approach appeared in the beginning of previous century when mathematics experienced deep fundamental crisis caused by the need for a formal definition of the very basis. At that time, multiple paradoxes in several fields of mathematics have been discovered. Moreover, the radically new theories appeared just by modification of the set of axioms, e.g., reducing the parallel postulate of Euclidean geometry has lead to completely different non-Euclidian geometries, such as Lobachevsky's hyperbolic geometry or Riemman's elliptic geometry, that eventually have a large number of applications in both natural sciences and engineering.


\subsection{Definition of the Formal System}
\label{sec:definitions}

% TODO: add citations!

%\texttt{Definition.}
Let the \textit{judgement} be an arbitrary statement. The \textit{formal proof} of the formula $\phi$ is a finite sequence of judgements $ ( \psi_i )_{i=1}^{n} $, where each $\psi_i$ is either an axiom $A_i$, or a formula inferred from the subset $\{ \psi_k \}_{k=1}^{i-1}$ of previously derived formulae according the \textit{rules of inference}. \textit{An axiom} $A_i \in A$ is a judgement evidently claimed to be true. \textit{A logical inference} is a transfer from one judgement (\textit{premise}) to another (\textit{consequence}), which preserves truth. In formal logic, inference is based entirely on the structure of those judgements, thereby, the result formal system represents the abstract model describing part of real world.

The formulae consist of \textit{propositional variables}, connected with \textit{logical connectives} (or logical operators) according to rules, defined by a formal language. The formulae, which satisfy such rules, are called \textit{well-formed formulae} (wff). Only wff can form judgements in a formal system. The propositional variable is an atomic formula which can be either true or false. The logical connective is a symbol in formal language that transforms one wff to another. Typically, the set of logical connectives contains negation $\neg$, conjunction $\land$, disjunction $\lor$, and implication $\rightarrow$ operators, although the combination of negation operator with any other of aforementioned operators will be already functionally complete (i.e., any formula can be represented with the usage of these two logical connectives).

The formal system described above does not contain any restriction on the form of propositional variables, such logic is called \textit{propositional logic}. However, if these variables are quantified on the sets, such logic is called \textit{first-order} or \textit{predicate logic}. Commonly, first-order logic has two quantifiers, the universal quantifier $\forall$ (means "for every"), and the existential quantifier $\exists$ (means "there exists"). Thereafter, the \textit{second-order logic} extends first-order logic by adding quantifiers over second-order objects -- relations defining the sets of sets. In turn, it can be extended by the \textit{higher-order logic}, which contain quantifiers over the arbitrary nested sets, or \textit{type theory}, which assigns a type for every expression in the formal language (for instance, the expression $\forall f: bool \rightarrow bool, f\ (f\ (f\ b)) = f\ b$ could be considered in higher-order logic).

Let $\Phi$ be a set of formulae. Initially, it consists of only \textit{hypotheses}, a priori true formulae, which are claimed to be already proved. The notation $\Phi \vdash \phi$ means that the formula $\phi$ is \textit{provable} from $\Phi$, if there exists a proof that infers $\phi$ from $\Phi$. The formula which is provable without additional premises is called \textit{tautology} and denoted as $ \vdash \phi $ (equivalently, $\emptyset \vdash \phi$). The formula is called \textit{contradiction} if \ $\vdash \neg \phi$. Obviously, all contradictions are equivalent in one formal system, hence they are denoted as $\bot$.
\begin{gather}\label{notation_infrule}
[\![ A_{1}; A_{2}; \dots A_{n} ]\!] \implies B \\
\equiv \{ A_{1}, A_{2}, \dots A_{n} \} \vdash B
\end{gather}

//where $\implies$ denotes implication

//which means $ $

//equals to , left-associative where implication is left-associative:
\begin{gather}
A_{1} \implies A_{2} \implies \dots \implies A_{n} \implies B \\
\equiv A_{1} \implies ( A_{2} \implies ( \dots \implies ( A_{n} \implies B)))
\end{gather}

// As an example of inference rule, the principal rule \textit{Modus ponens} (MP) can be considered: 
\begin{equation}\label{rule_modus_ponens}\tag{MP}
[\![ A, A \implies B ]\!] \implies B
\end{equation}

Together with axioms \eqref{axiom_hilbert_1} and \eqref{axiom_hilbert_2}, Modus ponens rule forms the Hilbert proof system which can process statements of classical propositional logic. %is not complete under classical semantics.
\begin{gather}
A \implies (B \implies A)
	\label{axiom_hilbert_1}\tag{A1} \\
%
(A \implies (B \implies C)) \implies ((A \implies B) \implies (A \implies C))
	\label{axiom_hilbert_2}\tag{A2}
\end{gather}

Other classic logic systems often include the axiom of excluded middle~\eqref{axiom_excluded_middle} and double negation rule~\eqref{rule_double_negation}:
\begin{gather}
A \lor \neg A
	\label{axiom_excluded_middle}\tag{EM} \\
%
\neg \neg A \Leftrightarrow A
\label{rule_double_negation}\tag{DN}
\end{gather}

Many classical logics may derive de Morgan's laws~\eqref{tauto_demorgan1},~\eqref{tauto_demorgan2}, the law of contraposition~\eqref{tauto_contrapos}, the Peirce's law~\eqref{tauto_peirce} and many other tautologies:
\begin{gather}
\neg (A \land B) \Leftrightarrow \neg A \lor \neg B 
    \label{tauto_demorgan1}\tag{DM1} \\
\neg (A \lor B) \Leftrightarrow \neg A \land \neg B 
    \label{tauto_demorgan2}\tag{DM2} \\
(A \rightarrow B) \implies (\neg B \rightarrow \neg A) 
    \label{tauto_contrapos}\tag{C} \\
((A \rightarrow B) \rightarrow A) \implies B
    \label{tauto_peirce}\tag{P}
\end{gather}

The axiom of excluded middle means that every statement is decidable, which may not be true in some applications. Adding this axiom to the formal system leads to the reasoning from \textit{truth} statements, in contrast to \textit{natural deduction systems} that use reasoning from \textit{assumptions}. Although the difference between these two kinds of formal systems seems to be subtle, the latter can be used more as framework, allowing to build new systems on the logical base of pre-defined premises and formal proof rules. % AUTHOR'S THOUGHTS, UNVERIFIED

\subsection{Properties of Formal System}

Let $U$ be a set of all possible formulae, let $\Gamma = \ <A, V, \Omega, R>$ be a formal system with set of axioms $A$, set of propositional variables $V$, set of logical operators $\Omega$, and set of inference rules $R$. Then $\Gamma$ is called:
\begin{itemize}
	\itemsep0em
	\item \textit{consistent}, if both formula and its negation can not be proved in the system: \\
		$\nexists \phi \in \Gamma: \ \Gamma \vdash \phi \land \Gamma \vdash \neg \phi  \ \Leftrightarrow \ \Gamma \nvdash \bot$;
	\item \textit{complete}, if all true statements can be inferred: \\
		$\forall \phi \in U: \ A \vdash \phi \lor A \vdash \neg \phi$ ;
	\item \textit{independent}, if no axiom can be inferred from another: \\
		$\not \exists a \in A: \ A \vdash a$.
\end{itemize}

In 1931, Kurt Gödel proved his first incompleteness theorem which states that any consistent formal system is incomplete. Later, in 1936, Alfred Tarski extended this result by proving his Undefinability theorem, which states that the concept of truth cannot be defined in a formal system. % originally: in arithmetic. Does that make sense?
In that case, modern tools, such as Coq, often restrict propositions to be either provable or unprovable, rather than true or false.


% TODO
// TODO -- finish it


Note, that the first-order logic is \textit{undecidable}, so that there does not exist a decision algorithm which is sound, complete and terminating [TODO: REFERENCE]. % TODO <-- 

for Isabelle: see slide 28 % https://www.it.uu.se/education/phd_studies/phd_courses/gc0910/isabelle/slide2.pdf
- Primitive-recursive with primrec
Terminating by construction
- Well-founded recursion with fun
Automatic termination proof
- Well-founded recursion with function
User-supplied termination proof


\subsection{Lambda-calculus}

$\lambda$-\textit{calculus} is a universal computation model invented by Alonzo Church in 1930s as a model for formalising the concept of effective computability.  This formalism provides solid theoretical foundation for the family of functional programming languages~\cite{Roj15}. In $\lambda$-calculus, functions are first-order objects, which means functions can be applied as arguments to other functions.

The central concept in $\lambda$-calculus is an \textit{expression}, which can be defined as a subject for application the rewriting rules~\cite{Bar88}. The basic rewriting rules of $\lambda$-calculus are listed below:

\begin{itemize}
\itemsep0em
	\item \textit{application}:
	$f a$ is the call of function $f$ with argument $a$
	
	\item \textit{abstraction}:
	$\lambda x.t[x]$ is the function with formal parameter x and body $t[x]$
	
	\item \textit{computation} ($\beta$-\textit{reduction}): replace formal parameter $x$ with actual argument $a$: \\
	$(\lambda x.t[x]) a \rightarrow_{\beta} t[x:=a]$
\end{itemize}

$\lambda$-calculus described above is called the \textit{type-free} $\lambda$-calculus. The more strong calculi can be constructed by using the types of expressions to the system, for which some useful properties can be proven (e.g., termination and memory safety)~\cite{Bar13}.

\subsection{Type Systems}

A \textit{type} is a collection of elements. In a type system, each element is associated with a type, which defines a basic structure of it and restricts set of possible operations with the element. This allows to reveal useful properties of the formal system. Therefore, type theory serves as an alternative to the classic set theory~\cite{Tho91}.
% TODO: remove notation below if not used.
In our notation, the $a =_{\tau} b$ means that $a$ equals $b$ and both of them are of type $\tau$. This notation is used for convenience to encode information about type to equality.

The function that builds a new type from another is called \textit{type constructor}. Such functions have been used long before type theories had been constructed formally, even in the~19th~century Giuseppe Peano used type constructor $S$ called the \textit{successor} function, along with zero element 0, to axiomatise natural number arithmetic. Thus, number 3 can be constructed as $S(S(S(0))))$.


\subsubsection{Simple Type Theory}
%In the context of current paper, it is useful to describe 
The type can be defined declaratively, by assigning a label to set of values. Such types are called \textit{simple types}, they can be useful to avoid some paradoxes of set theory, e.g., separating sets of individuals and sets of sets allows to avoid famous Russel's paradox~\cite{Irv95}. Simple type theory can extend $\lambda$-calculus to a higher-order logic through connection between formulae and expressions of type Boolean~\cite{Paulson90}.

% TODO: // == Pure Type System ?
% https://www.cl.cam.ac.uk/teaching/1516/Types/lectures/lecture-9.pdf
% https://en.wikiversity.org/wiki/Foundations_of_Functional_Programming/Pure_type_systems
% http://www4.di.uminho.pt/~mjf/pub/SFV-CIC-2up.pd


% TODO: // == Polymorphic Type Theory ?
%\subsubsection{Polymorphic Type Theory}
% //not needed
% --
% \subsubsection{System F}
% second-order lambda calculus, is a typed lambda calculus that differs from the simply typed lambda calculus by the introduction of a mechanism of universal quantification over types
% //not needed


\subsubsection{Martin-Löf Type Theory}
The Martin-Löf type theory, also known as the \textit{Intuitionistic type theory}, is based on the principles of mathematical constructivism, that require explicit definition of the way of "constructing" an object in order to prove its existence. Therefore, an important place in intuitionistic type theory is held by the \textit{inductive types}, which were constructed recursively using a basic type (zero) and successor function which defines "next" element.

The Intuitionistic type theory also uses a wide class of \textit{dependent types}, whose definition depends on a value. For instance, the $n$-ary tuple is a dependent type that is defined by the value of~$n$. However, the type checking for such a system is an undecidable problem since determining of the equality of two arbitrary dependent types turns to be tantamount to a problem of inducing the equivalence of two non-trivial programs (which is undecidable in general case according to the Rice's theorem~\cite{Rice53}).

%A language with dependent types may include references to programs inside of types. For instance, the type of an array might include a program expression giving the size of the array, making it possible to verify absence of out-of-bounds accesses statically. Dependent types can go even further than this, effectively capturing any correctness property in a type. PVS’s dependent types are much more general, but they are squeezed inside the single mechanism of subset types, where a normal type is refined by attaching a predicate over its elements. Each member of the subset type is an element of the base type that satisfies the predicate. 


\subsubsection{Calculus of Constructions}
% TODO: figure out how this implies to PTS - Pure Type Systems

Another important constructive type theory is the Calculus of Constructions~(CoC) developed by Thierry~Coquand and Gérard~Huet in 1985~\cite{Coq85}. It represents a natural deduction system which incorporates dependent types, polymorphism and type constructors.

% TODO
// TODO: MORE DEFINITIONS HERE
% see also the Coq documentation: https://coq.inria.fr/refman/cic.html#conv-rules

%The Calculus of Construction can be considered as an extension of the Curry–Howard isomorphism. % in a way that the latter associates a term in the simply typed lambda calculus with each natural-deduction proof in intuitionistic propositional logic, when the Calculus of Construction extends this isomorphism to proofs in the full intuitionistic predicate calculus, which includes proofs of quantified statements (which are also called "propositions").

The CoC has \text{strong normalisation property}, which means that every sequence of inference eventually terminates with an irreducible normal form. This property does not allow to define infinitely recursive structures and functions. % TODO: check whether one can say that with respect to any formal system, not only to an abstract rewriting system

%Inference rules for the Calculus of Constructions:
%\begin{enumerate}
%    \item ${\displaystyle {{} \over {}\Gamma \vdash P:T}}$
%    \item ${\displaystyle {\Gamma \vdash A:K \over {\Gamma ,x:A\vdash x:A}}}$
%    \item ${\displaystyle {\Gamma ,x:A\vdash B:K\qquad \Gamma ,x:A\vdash N:B \over {\Gamma \vdash (\lambda x:A.N):(\forall x:A.B):K}}}$
%    \item ${\displaystyle {\Gamma \vdash M:(\forall x:A.B)\qquad \Gamma \vdash N:A \over {\Gamma \vdash MN:B[x:=N]}}}$
%    \item ${\displaystyle {\Gamma \vdash M:A\qquad A=_{\beta }B\qquad B:K \over {\Gamma \vdash M:B}}}$ % \over {\Gamma \vdash M : B}}
%\end{enumerate}
%
%// TODO: add explanations to the inference rules or delete them

In 1990, Christine Paulin proposed the \textit{Calculus of Inductive Constructions}~(CIC) as an extension of Calculus of Construction by adding the Martin-Löf's primitive inductive definitions in order to perform efficient computation of the functions over inductive data types~\cite{Pau2015}. This formalism lies behind the Coq proof assistant.

%----------------------------------------------------------


\subsection{Curry-Howard isomorphism}
% TODO
// TODO -- this is the most delicious idea among those described in this paper...

"proofs are programs"
% http://perso.ens-lyon.fr/damien.pous/ejcp13/slides.pdf slide 9 - draw the same pic
% +show correspondence in two-column view
bla-bla correspondence, isomorphism, very interesting thing...
% 1934–1969

%============================================================

% Probably exclude this paragraph.

%\section{Methods for automated reasoning}
%\label{sec:auto_reasoning}

%techniques in common words (and in introduced previously notation), e.g.: 
%\begin{itemize}
%\itemsep0em
%	\item Clause rewriting
%		Simplification - The concept of (conditional) term rewriting is introduced and its realization as the proof method simp is explained. (from http://isabelle.in.tum.de/coursematerial/PSV2009-1/)
		
%	\item Resolution
%	\item Sequent Deduction
%	\item Natural Deduction
%	\item The Matrix Connection Method
%	\item Term Rewriting (+lambda calculus)
%	\item Mathematical Induction
%\end{itemize}


%============================================================


\section{Comparison of two theorem provers}
\label{sec:comparison}

We have chosen for our comparison two automated proof assistants, \textit{Coq} and \textit{Isabelle/HOL}\footnote{Roughly speaking, Isabelle is a core for an automated theorem proving which supports multiple logical theories: Higher-Order Logic (HOL), first-order logic theories such as Zermelo-Fraenkel Set Theory (ZF), Classical Computational Logic (CCL), etc. In this paper, we consider the Isabelle/HOL as the startpoint for exploring the power of this proof assistant.} as they both are widely used tools for theorem proving.

%------------------------------------------------------------

\subsection{The Coq theorem prover}
\label{sec:prover_coq}

Coq is a formal proof assistant system which has been developed at INRIA (Paris, France) since 1984. As a proof assistant system, Coq offers multiple interactive proof methods called \textit{tactics} and decision algorithms for letting the user define new proof methods. A key feature of Coq is a capability of extraction of the verified program (in OCaml, Haskell or Scheme) from the constructive proof of its formal specification~\cite{Let08}. This facilitates using Coq as a tool for software verification.

During the proof process, Coq remembers its state, a set of \textit{premises}, which are considered to be true, and set of \textit{goals} (or subgoals), the statements to be proved. The proof consists of sequence of commands describing which tactic Coq should apply. Tactic may be thought as an inference rule, it can use already proved statements, remove hypotheses or introduce variables. Coq may sometimes find an appropriate tactic from its collection in automatic mode.

In proofs, Coq combines two languages: \textit{Gallina}, a purely functional programming language, and \textit{Ltac}, a procedural language for manipulating the proof process. A statement for proof and structures it relies on are written in Gallina, and calls of the tactics (inference rules) are written in Ltac.

%// "Coq's built-in logic is very small: the only primitives are Inductive definitions, universal quantification (forall), and implication (->), while all the other familiar logical connectives — conjunction, disjunction, negation, existential quantification, even equality — can be encoded using just these."
%// https://softwarefoundations.cis.upenn.edu/sf-3.2/Logic.html

// In Coq, "Implications are functions" => theorems statements may be seen as functions

// ?else?

%http://www.seas.upenn.edu/~cis500/current/sf/lf-current/Basics.html#lab30


%------------------------------------------------------------

\subsection{The Isabelle/HOL theorem prover}
\label{sec:prover_isabelle}

Isabelle was developed by Larry Paulson in Technical University of Munich as a successor of HOL theorem prover~\cite{tool_HOL}. Isabelle was released for the first time in 1986 (two years after the Coq's first release). It was built in a modular manner, i.e., it has relatively small core, which can be extended by numerous basic theories that describe logic behind Isabelle. In particular, the theory of higher-order logic is implemented as Isabelle/HOL, and it is commonly used because of its expressivity and relative conciseness. Similarly to Coq, it combines several languages in its proofs: HOL as a functional programming language (which must be always in quotes), and the language for describing procedures for manipulating the proof. Unlike Coq, Isabelle supports more expressive style of proofs written in a declarative fashion in language \textit{Isar}.

// IDE allows to randomly pick jump to any place in the syntax tree of the proof and view the state (in spite of Coq, where only the forward-backward operations are allowed).

% citing: """Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification."""

// some words on termination checks in Isabelle (unlike Coq)
%Termination: "The method lexicographic_order is the default method for termination proofs.
% https://isabelle.in.tum.de/doc/functions.pdf page 4 - !!! (relation method, lexicographic order, ...)

// termination of computation. see: % https://www.joachim-breitner.de/blog/732-Isabelle_functions__Always_total%2C_sometimes_undefined

// ?else?

%------------------------------------------------------------


\subsection{Common features}

In general, both Coq and Isabelle work in a similar way: given definition of a statement, they can either verify already written proof, or help user to develop such proof in an interactive fashion, so that the invalid proofs cannot be accepted. Both systems have rather large libraries with considerable amount of already proven lemmas and theorems; in addition, they can be used as functional programming languages as they allow to construct new data types and recursive functions, they have pattern matching, type inference and other features inherent for functional languages.

Both tools are being actively developed: on the moment of writing this paper (autumn 2017), the latest versions were Coq 8.7.0 (stable) and Isabelle2017, both released in October 2017. Since their first release, both Coq and Isabelle have already been used to formalize enormous amount of mathematical theorems, including those which have very large or even controversial proof, such as Four colour theorem (2004), Lax-Milgram theorem (2017), and other important theorems~\cite{Wiedijk100}. Moreover, the theorem provers have been successfully used for testing and verifying of software programs, including the general-purpose operating system kernel~seL4~(2009)~\cite{Klein09}, the C~standard~(2015)~\cite{Krebbers15}, and others.

Both Coq and Isabelle have their own Integrated Development Environment (IDE) to work in (gtk-based CoqIDE and jEdit Prover IDE, respectively). In general, both native IDEs of these theorem provers provide the facility for interactive executing scripts step-by-step while preserving the state of proof (\textit{environment}), which for each step describes the set of premises along with already proved statements (\textit{context}) and the set of statements to be proven (\textit{goals}). However, Isabelle's native IDE allows to change the proof state arbitrarily, in contrast to the CoqIDE, which provides only the capability of switching the proof state to the next or previous statement only. Alternatively, both considering theorem provers have numerous of plugins for many popular IDEs, for instance, the Proof General~\cite{tool_PG} is a plugin for Emacs, which supports numerous proof assistants. During the work on this paper, we used the native IDEs of each proof assistant in order to minimize the impact of third-party tools to our research.

Both systems admit proofs written in imperative fashion, i.e., such proof is a sequence of tactic calls compound by control-flow operators -- tacticals -- which combine tactics together, separate their results, repeat calls, etc. In addition, the syntax of Isar permits writing the goals explicitly in the proof code (see Example~\ref{ex_isb_arith_sum}).

//Basic types are described in similar way in both Coq and Isabelle. 

%------------------------------------------------------------

\subsection{Differences}

The key difference between Coq and Isabelle lies in the difference between logical theories they based on. While Isabelle/HOL exploits higher order logic along with decidable non-dependent types, Coq is based on Calculus of Inductive Constructions, which uses inductive and dependent types and represents an implementation of intuitionistic logic. Essentially, intuitionistic logic does not include the axiom of excluded middle~\eqref{axiom_excluded_middle} and the double negation elimination rule~\eqref{rule_double_negation}.
Therefore, numerous of theorems are not provable in intuitionistic logic, while being valid in classic logic, which makes the latter strictly weaker~\cite{Rush14} (for example, the classical logic tautology Peirce's law~\eqref{tauto_peirce} cannot be proven in intuitionistic logic).

The following proof of the is a classical example that illustrates the inapplicability of some classic logic proofs which are valid, but in fact are unexploitable in applied problems. The theorem states that there exist algebraic irrational numbers $x$ and $y$ such that $x^y$ is rational. The proof relies on the axiom of excluded middle~\cite{Harrison09}. Consider the number $\sqrt{2}^{\sqrt{2}}$. If it is rational, then consider $x = \sqrt{2}$ and $y = \sqrt{2}$, which both are irrational. If $\sqrt{2}^{\sqrt{2}}$ is irrational, then consider $x = \sqrt{2}^{\sqrt{2}}$ and $y = \sqrt{2}^{2}$, so that $x^{y}$ is rational, qed. Although this proof is clear and concise, it reveals no information about whether the number $\sqrt{2}^{\sqrt{2}}$ is irrational. More importantly, it gives no algorithm for finding such numbers. Therefore, the main purpose of constructive proofs used in intuitionistic logics is to define such a solution schema for a problem, in addition to simply proving the claims.
Commonly, the proofs of existence of an element are non-constructive as in order to prove such a statement it is enough to find a valid example. %TODO: perhaps, remove last sentence.

%TODO: // intuit. : completeness, ...
%TODO: // class.:  complet... 

%------------------------------------------------------------

\subsection{Example Proofs}

Current section provides several proof examples that may ...//Let's prove some propositional tautologies here

\subsubsection{Propositional Intuitionistic Logic in Coq}

<tauto - the tactic to automatically prove propositional tautologies (need definition of tautology)>

//Let's prove that ~$\vdash (P \lor \neg P) $

\begin{lstlisting}[language=coq]
Theorem DeMorgan_Auto_Coq : forall P Q : Prop, 
    ~P /\ ~Q <-> ~(P \/ Q).
Proof.
    tauto.
Qed.
\end{lstlisting}


<but Coq's logic does not include the axiom of excluded middle:>
% from here https://coq.inria.fr/tutorial/1-basic-predicate-calculus
\begin{lstlisting}[language=coq]
Lemma ExcludedMiddle_AutoFails_Coq:
    forall P, P \/ ~P.
Proof.
    try tauto.  (* tauto fails in Coq's intuitionistic logic *)
Abort.
\end{lstlisting}

// Note, that Coq's logic can be extended by assuming the excluded middle fact as an axiom (we use that in the proof ??? of nth number of arith progr)

Nonetheless, <idea: Assuming NOT(A OR NOT A), you first prove ~A, then find a contradiction.>
% source: http://coq-club.inria.narkive.com/jqsPmOBk/is-a-prop-a-a-provable-in-coq
% from here https://stackoverflow.com/a/32813110 
% TODO: Make a reference to that answer or to the mailing list. OR BETTER DIRECTLY TO GLIVENKO'S THM!!! double-negation translation
%"If φ is a propositional formula, then φ is a classical tautology if and only if ¬¬φ is an intuitionistic tautology."

\begin{lstlisting}[language=coq]
Lemma DoubleNegatedExcludedMiddle_Coq:
    forall P : Prop, ~~(P \/ ~P).
Proof.
    unfold not.    (* apply ~P ==> P -> False *)
    intros P f.    (* move premises to the set of hypotheses *)
    apply f.       (* replace the goal with premise of implication in f *)
    right.         (* apply disjunction elimination inference rule *)
    intro P_holds. (* move P to the set of hypotheses *)
    apply f.       (* replace the goal with premise of implication in f *)
    left.          (* apply disjunction elimination inference rule *)
    exact P_holds. (* match the goal with one of the hypotheses *)
Qed.
\end{lstlisting}

// so, in this way intuitionistic logic can model classic logic (?)

In Isabelle, vice versa: it can model intuitionistic logic by not using the excluded middle law (see theory IFOL [REFERENCE]):  % FOL: http://isabelle.in.tum.de/library/FOL/FOL/document.pdf

Still, double negation is easily proved in classic logic:
\begin{lstlisting}[language=isabelle]
\end{lstlisting}


//Figure~\ref{Coq:DeMorgan_Prop} shows the proof of De Morgan's law in Coq system. The law statement is being proved for all propositions of type \texttt{Prop}  <which is ...> ... . For arguments of type \texttt{bool} the proof is trivial.

//Let's prove that $\neg (P \lor Q) \leftrightarrow (\neg P \land \neg Q)$
    (* this simple propositional formula can be easily solved by the tactic tauto *)
    
\begin{lstlisting}[language=coq,caption={Proof of propositional logic tautology in Coq: the de Morgan's law for propositions},label={DeMorganPropositional_Coq}]
Theorem DeMorganPropositional_Coq:
    forall P Q : Prop, ~(P \/ Q) <-> ~P /\ ~Q.
Proof.
    intros P Q. unfold iff.
    split.
    - intros H_not_or. unfold not. constructor.
      + intro H_P. apply H_not_or. left. apply H_P.
      + intro H_Q. apply H_not_or. right. apply H_Q.
    - intros H_and_not H_or.
      destruct H_and_not as [H_not_P H_not_Q].
      destruct H_or as [H_P | H_Q].
      + apply H_not_P. assumption.
      + apply H_not_Q. assumption.
Qed.
\end{lstlisting}


//For Isabelle, same proof:
% source: https://www.inf.ed.ac.uk/teaching/courses/ar/isabelle/exercises/propositional/sol.pdf
\begin{lstlisting}[language=isabelle]
lemma DeMorganPropositional_Isabelle: "(\<not> (P \<and> Q)) = (\<not> P \<or> \<not> Q)"
(* 'apply blast' automatically solves the equasion *)

apply (rule iffI)      (* split equality into two subgoals *)
(* "Forward" subgoal: 1. \<not>(P \<and> Q) ==> \<not> P \<or> \<not> Q *)
apply (rule classical) (* 1. \<not> (P \<and> Q) ==> \<not> (\<not> P \<or> \<not> Q) ==> \<not> P \<or> \<not> Q *)
apply (erule notE)     (* 1. \<not> (\<not> P \<or> \<not> Q) ==> P \<and> Q *)
apply (rule conjI)     (* 1. \<not> (\<not> P \<or> \<not> Q) ==> P; 2. \<not> (\<not> P \<or> \<not> Q) ==> Q *)
apply (rule classical) (* 1. \<not> (\<not> P \<or> \<not> Q) ==> \<not> P ==> P *)
apply (erule notE)     (* 1. \<not> P ==> \<not> P \<or> \<not> Q *)
apply (rule disjI1)    (* 1. \<not> P ==> \<not> P *)
apply assumption       (* 1. (solved). 2. \<not> (\<not> P \<or> \<not> Q) ==> Q *)
apply (rule classical) (* 2. \<not> (\<not> P \<or> \<not> Q) ==> \<not> Q ==> Q *)
apply (erule notE)     (* 2. \<not> Q ==> \<not> P \<or> \<not> Q *)
apply (rule disjI2)    (* 2. \<not> Q ==> \<not> Q *)
apply assumption       (* 2. (solved) *)
(* "Backward" subgoal: 3. \<not> P \<or> \<not> Q ==> \<not> (P \<and> Q) *)
apply (rule notI)   (* 3. \<not> P \<or> \<not> Q ==> P \<and> Q ==> False *)   
apply (erule conjE) (* 3. \<not> P \<or> \<not> Q ==> P ==> Q ==> False *)
apply (erule disjE) (* 3. P ==> Q ==> \<not>P ==>False; 4. P ==> Q==> \<not>Q==> False *)
apply (erule notE, assumption)+  (* 3. (solved); 4. (solved) *)

done
\end{lstlisting}

%------------------------------------------------------------

\subsubsection{First-order Logic Proofs}

// see slide 53 from %https://www.labri.fr/perso/casteran/CoqArt/Tsinghua/C3.pdf
%// "Predicates : a Predicate is just any function of type A1→A2 . . .An→Prop where Ai : Set for each i. Predicates are declared as any other function symbol"

% HONESTLY I TOOK THE PROOF FROM http://flint.cs.yale.edu/cs428/coq/library/Coq.Logic.Classical_Pred_Type.html
\begin{lstlisting}[language=coq]
Require Import Coq.Logic.Classical_Prop.  (* to use classical logic axioms *)

Lemma DeMorganQuantified_Coq:
    forall (P:Type -> Prop), ~(forall x:Type, P x) -> exists x:A, ~P x.
Proof.
    unfold not.             (* unfold negation *)
    intros P H_notall.      (* move premises to the set of hypotheses *)
    apply NNPP.             (* apply ~~P ==> P *)
    unfold not.
    intro H_not_notexist.
    cut (forall x:A, P x).       (* add new goal from the goal's premise *)
    exact H_notall.
    intro x.
    apply NNPP.
    unfold not.
    intros H_not_P_x.
    apply H_not_notexist.
    [*\color{dkblue}{exists}*] x.
    exact H_not_P_x.
Qed.
\end{lstlisting}

For Isabelle, see here %https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle/browser_info/HOL/HOL-Proofs-ex/Drinker.html
\begin{lstlisting}[language=isabelle]
lemma DeMorganQuantified_Isabelle:
    assumes "\<not> (\<forall>x. P x)"
    shows "\<exists>x. \<not> P x"
    proof (rule classical)
        assume "\<nexists>x. \<not> P x"
        have "\<forall>x. P x"
        proof
            fix x show "P x"
            proof (rule classical)
                assume "\<not> P x"
                then have "\<exists>x. \<not> P x" ..
                with <\<nexists>x. \<not> P x> show ?thesis by contradiction
        qed
    qed
    with <\<not>(\<forall>x. P x)> show ?thesis by contradiction
qed
\end{lstlisting}


%------------------------------------------------------------
%\subsubsection{Higher-Order Logic Proofs}
%Coq: from %https://github.com/blindFS/Software-Foundations-Solutions/blob/master/MoreCoq.v
%\begin{lstlisting}[language=Coq]
%Theorem bool_fn_applied_thrice : 
%    forall (f : bool -> bool) (b : bool),
%    f (f (f b)) = f b.
%Proof.
%    intros f b.
%    destruct b.
%    destruct (f true) eqn:eq. rewrite eq. rewrite eq. reflexivity.
%    destruct (f false) eqn:eq1. apply eq. apply eq1.
%    destruct (f false) eqn:eq.
%    destruct (f true) eqn:eq1. apply eq1. apply eq.
%    rewrite eq. rewrite eq. reflexivity.
%Qed.
%\end{lstlisting}

%------------------------------------------------------------

\subsubsection{Intuitionistic Type Theory}

<here bool the datatype, which is inductively defined as a \texttt{Set} => can use destruct, which expands the definition of inductive type>
\begin{lstlisting}[language=coq,caption={Propositional logic proof: de Morgan's law for booleans},label={Coq:DeMorgan_bool}]
(* define macroses: *)
Notation "a || b" := (orb a b).
Notation "a && b" := (andb a b).

Theorem DeMorganBoolean_Coq:
    forall a b: bool, negb (a || b) = ((negb a) && (negb b)).
Proof.
    intros a b.
    destruct a; simpl; reflexivity.
Qed.
\end{lstlisting}
//for Isabelle, see p.10 'Polymorph. types', e.g. prove "Suc = Suc" %http://isabelle.in.tum.de/doc/intro.pdf


% also see https://gist.github.com/bbc2/092e224a78f17ed9c437


// Peano
\begin{lstlisting}[language=coq]
Inductive nat : Type :=
	| O : nat
	| S : nat -> nat.
\end{lstlisting}

\begin{lstlisting}[caption={Recursive function definition: factorial}]
... example here with 'Fixpoint' and 'Inductive'
...//fix x (v : V) : X := t Recursive function.
\end{lstlisting}
// "Syntactic restriction on recursive calls on term":
// Coq doesn't allow to define recursive functions without decreasing argument => always terminates

\begin{lstlisting}[caption={Inductive data type definition: ???}]
...
...
\end{lstlisting}


// ... A practical example: proof of correctness of an algorithm which sums n first members of arithmetic progression using formula $S_{n} = { {\frac {2 a_{1} + d (n - 1)}{2} \cdot n}}$ through direct counting of this sum: $S_{n} = \sum\limits_{k=0}^{n-1} (a_{1} + d \cdot k)$.

Isabelle:


\begin{lstlisting}[language=isabelle,caption={???},label={ex_isb_arith_sum}]
fun range_sum :: "nat => nat"
	where "range_sum n = (\<Sum>k::nat=0..n . k)"
value "range_sum 10"

theorem SimpleArithProgressionSumFormula_Isabelle: "2 * (range_sum n) = n * (n + 1)"
  proof (induct n)
    show "2 * range_sum 0 = 0 * (0 + 1)" by simp
  next
  fix n have "2 * range_sum (n + 1) = 2 * (range_sum n) + 2 * (n + 1)" by simp
  also assume "2 * (range_sum n) = n * (n + 1)"
  also have "\<dots> + 2 * (n + 1) = (n + 1) * (n + 2)" by simp
  finally show "2 * (range_sum (Suc n)) = (Suc n) * (Suc n + 1)" by simp
qed
\end{lstlisting}



proofs by simplification (\texttt{omega} in Coq)
% source: https://coq.inria.fr/library/Coq.Logic.Classical_Pred_Type.html
\begin{lstlisting}[language=coq]
Require Import Coq.[*omega*].Omega.
Require Coq.Logic.Classical.

Fixpoint range_sum (n: nat) : nat :=
match n with
    | O => 0
    | S p => range_sum p + (S p)
end.
Compute range_sum 3.  (* output: '= 6 : nat' *)

Lemma range_sum_lemma: forall n: nat,
    range_sum (n + 1) = range_sum n + (n + 1).
Proof.
    intros.
    induction n.
    - simpl; reflexivity.
    - simpl; omega.
Qed.

Theorem SimpleArithProgressionSumFormula_Coq: forall n,
    2 * range_sum n = n * (n + 1).
Proof.
intros.
induction n.
(* goal: '2 * range_sum 0 = 0 * (0 + 1)' *)
 - simpl; reflexivity.
(* goal: '2 * range_sum (S n) = S n * (S n + 1)' *)
 - rewrite -> Nat.mul_add_distr_l. (* '2*range_sum(S n) = S n * S n + S n * 1' *)
   rewrite -> Nat.mul_1_r.         (* '2*range_sum(S n) = S n * S n + S n' *)
   rewrite -> (Nat.mul_succ_l n).  (* '2*range_sum(S n) = n * S n + S n + S n' *)
   rewrite <- (Nat.add_1_r n).     (* '2*range_sum(n+1) = n*(n+1)+(n+1)+(n+1)' *)
   rewrite -> range_sum_lemma.  (* '2*(range_sum(n)+(n+1)) = n*(n+1)+(n+1)+(n+1)' *)
   omega.                          (* automatically solve arithmetic equation *)
Qed.
\end{lstlisting}


Extracted verified function \texttt{range\_sum}:

\begin{minipage}{.45\columnwidth}
\begin{lstlisting}[caption={Extracted function in Haskell},frame=none]
range_sum :: Nat -> Nat
range_sum n =
  case n of {
    O -> O;
    S p -> add (range_sum p) (S p)}
\end{lstlisting}
\end{minipage}
\begin{minipage}{.45\columnwidth}
\begin{lstlisting}[caption={Extracted function in OCaml},frame=none]
(** val range_sum : nat -> nat **)

let rec range_sum = function
| O -> O
| S p -> add (range_sum p) (S p)
\end{lstlisting}
\end{minipage}
%\vspace{3pt}




%\begin{lstlisting}[language=isabelle,caption={First-order logic proof: formula of the sum of n first members of arithmetic progression}]
%primrec nth_member :: "nat => nat => nat => nat"
%	where "nth_member a_0 d 0 = a_0"
%	| "nth_member a_0 d (Suc p) = d + (nth_member a_0 d p)"
%
%theorem "(nth_member a_0 d n) = a_0 + d * n"
%	apply (induct n)
%	apply (auto)
%	done
%\end{lstlisting}
























// Isabelle's feature: non-constructive logic!
%- иллюстрация доказательства в классической логике, от противного. Теор Кантора
%https://isabelle.in.tum.de/doc/prog-prove.pdf стр 42.
\begin{lstlisting}[caption={Propositional logic proof to the contrary}]
Lemma DeMorgan_1 : (forall A B : Prop, ~(A /\ B) -> ~A \/ ~B).
Proof.
intros.
...
Qed.
\end{lstlisting}

// Useful features: automatically find a model (SAT)
\begin{lstlisting}[caption={Isabelle as an SAT solver}]
... nitpick - finds a model
...
\end{lstlisting}

%// Sometimes Isabelle advices how it is possible to prove a statement more easily
%иногда Подсказывает, как можно проще доказать
%напр, для ассоциативности дизъюнкции, lemma disj_swap: "P ∨ Q ⟹ Q ∨ P"
%proof (prove)
%goal (1 subgoal):
%1. P ∨ Q ⟹ Q ∨ P 
%Auto solve_direct: the current goal can be solved directly with
%Meson.disj_comm: ?P ∨ ?Q ⟹ ?Q ∨ ?P
%// overview good at: https://pdfs.semanticscholar.org/95bf/a1bf0cbf5ae2c2a70daa13d4966143bd96f8.pdf




% FOR ISABELLE SUMMATION: https://github.com/seL4/isabelle/blob/master/src/HOL/Isar_Examples/Summation.thy 
// ... [Also] A practical example: proof of correctness of an algorithm which sums n first members of arithmetic progression using formula $S_{n} = { {\frac {2 a_{1} + d (n - 1)}{2} \cdot n}}$ through direct counting of this sum: $S_{n} = \sum\limits_{k=0}^{n-1} (a_{1} + d \cdot k)$.
%https://coq.inria.fr/library/Coq.Logic.Classical_Pred_Type.html
%, label={lst:example1}]
\begin{lstlisting}[caption={First-order logic proof: formula of the sum of n first members of arithmetic progression}]
Lemma ... ... 
Proof.
...
...
...
Qed.
\end{lstlisting}




%------------------------------------------------------------


% see https://people.cs.kuleuven.be/~bart.jacobs/coq-essence.pdf, 11 Coq versus classical logic

\subsection{Results of comparison}
\label{sec:joint_comparison}

//TODO: perhaps in table:
\begin{itemize}
	\itemsep0em
	\item expressiveness of logic used
	\item time of proving
	\item num of supporting theories
	\item set of techniques to prove automatically
	\item Volume of proof (as text)
	\item num of user interaction steps
	\item usability
	\item etc ...
\end{itemize}


Coq requires more mathematical background to even understand manuals (not just tactics, but rather deep knowledge of lambda-calculus to understand different types of reduction, functional programming and inductively created types ... ... ...)

Isabelle has more powerful meta-language syntax to operate tactics: it allows to use the functional combinators of tactics called tacticals for building up complex tactics from simpler ones. Common tacticals perform sequential composition, disjunctive choice, iteration, or goal addressing, which make Isar the Turing-complete language in the domain of logic <TODO: say better (?)>. [REFERENCE: implementaion.pdf in Isabelle Jedit]. In comparison, Coq allows to use only the composition of tactics. 
NOTE!!! Coq allows combinations of tactics as well, see: %https://stackoverflow.com/questions/43823343/how-to-repeat-proof-tactics-in-case-in-coq

Moreover, Isar allow more relaxed syntax in sense that its proof may look more like mathematical proof because of writing the goals during the proof (e.g., '\isabelleinline{assume "\<not> P x" then have "\<exists>x. \<not> P x"}') and using the connectors that can be read conveniently by human (e.g., '\isabelleinline{then}' abbreviates '\isabelleinline{from this}', '\isabelleinline{hence}' expands to '\isabelleinline{then have}', etc.). In contrast, proofs written in Coq look more like programs written in imperative programming language: the sequence of states need to be executed in order to check how the directives (application of tactics) change the state of proof. On the other hand, the brevity of Gallina language may let the experienced user, that knows the syntax and tactics well, spend less time for writing the proof in Coq rather than in Isabelle.

Isabelle is very well documented, all its manuals and documentation is compiled as a set of pdf files and is supplied with Isabelle setup bundle. Coq's manuals were in web, so numerous of files were inaccessible or even lost.


% у isabelle вначале предполагаем, потом проверяем, у coq просто приходим к этому

%============================================================


\section{Future work}
\label{sec:future_work}

// TODO (Paragraph is still in progress)

< in future, we want to apply this survey to software verification >

%============================================================

\bibliographystyle{ieeetr}
\bibliography{cs-seminar}

%============================================================

\newpage
\appendix

\section{Appendix}
% TODO: sverstat appendix correctly

%decrease space between
\bgroup
\def\arraystretch{0}%  1 is the default, change whatever you need
\begin{tabular}{p{.45\linewidth} p{.45\linewidth}}
\begin{center}Basic propositions definition in Isabelle\end{center}  &  \begin{center}Basic propositions definition in Coq\end{center} \\
\begin{isabelle}
    (* In Isabelle, boolean type is defined simply as two-element enumeration, tertium non datur *)
    datatype bool = True | False
\end{isabelle}
&
\begin{coq}
    (* In Coq, False is an unobservable proposition, which is defined as a type without constructor *)
    Inductive False : Prop := .
    
    (* On other hand, True is defined as always true proposition *)
    Inductive True : Prop := I : True.
\end{coq}
\\ \arrayrulecolor{gray}\hline

\begin{center}Peano's natural numbers in Isabelle\end{center}  &  \begin{center}Peano's natural numbers in Coq\end{center} \\
\begin{isabelle}
    datatype nat = 
    zero ("0")
    | Suc nat
\end{isabelle}
&
\begin{coq}
    Inductive nat : Type :=
    | O : nat
    | S : nat -> nat.
\end{coq}
\\ \arrayrulecolor{gray}\hline

\begin{center}Addition in Isabelle\end{center}  &  \begin{center}Addition in Coq\end{center} \\
\begin{isabelle}
    fun add :: "nat => nat => nat" where
    "add 0 n = n"
    | "add (Suc m) n = Suc(add m n)"
\end{isabelle}
&
\begin{coq}
    Fixpoint add (n m:nat) : nat :=
    match n with
    | O => m
    | S p => S (p + m)
    end
    where "n + m" := (add n m) : nat_scope.
\end{coq}
\\ \arrayrulecolor{gray}\hline

\begin{center}Higher-order statement in Isabelle\end{center}  &  \begin{center}Higher-order statement in Coq\end{center} \\
\begin{isabelle}
lemma lem:
"\<forall> (f::bool=>bool) (b::bool) .
    f (f (f b)) = f b"
\end{isabelle}
&
\begin{coq}
Lemma lem: 
forall (f : bool -> bool) (b : bool),
    f (f (f b)) = f b.
\end{coq}
\\ \arrayrulecolor{gray}\hline
\end{tabular}

Inductive datatype

Isabelle:"datatype ’a list = Nil | Cons ’a (’a list)" %https://www.it.uu.se/education/phd_studies/phd_courses/gc0910/isabelle/slide2.pdf



\end{document}