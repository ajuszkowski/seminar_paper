\documentclass[article]{aaltoseries}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}  % remove spaces before enumerations and lists
\usepackage{url}
\begin{document}

%=========================================================

\title{Comparison of theorem provers}

\author{Artem Yushkovskiy
\\\textnormal{\texttt{artem.yushkovskiy@aalto.fi}}}

\affiliation{\textbf{Tutor}: Stavros Tripakis}

\maketitle

%==========================================================

\begin{abstract}
One of the useful applications of mathematical logic theory is Automated theorem proving. This is a set of techniques that allow one to verify mathematical statements mechanically using logical reasoning. Although it can be used to solve engineering problems as well, for instance, to prove security properties for a software system or an algorithm.
% TODO: probably drop out the sentence below ("i'm not sure in what sense theorem proving is part of AI, but i guess you'll describe this below")
Furthermore, automated theorem proving is an essential part of the Artificial Intelligence theory, which is highly evolving in recent years.
%continue...
This paper compares two widespread tools for automated theorem proving, Coq~\cite{tool_Coq} and Isabelle~\cite{tool_Isabelle}, with respect to the power of expressiveness and usability. For this reason, it firstly gives a brief introduction to the bases of formal systems and automated deduction theory, its main problems and challenges.

\vspace{3mm}
\noindent KEYWORDS: logic, formal method, proof theory, automated theorem prover, Coq, Isabelle.
	
\end{abstract}


%============================================================

\section{Introduction}

Nowadays, the search for foundations of mathematics has become one of the key questions in philosophy of mathematics, which eventually have an impact on numerous problems in modern life. Basically, this search has led to the development of \textit{formal approach}, a methodology for manipulating the abstract essences according basic rules in a verifiable way. In other words, it is possible to follow the sequence of such manipulations in order to check the validity of each statement and, as a result, of a system at whole. Moreover, automating such a verification process can significantly increase reliability of formal models and systems based on them.

At present, a large number of tools have been developed to automate this process. In particular, the systems \textit{Isabelle/ZF}~\cite{tool_Isabelle}, \textit{Coq}~\cite{tool_Coq}, \textit{PVS}~\cite{tool_Pvs}, \textit{ACL2}~\cite{tool_Acl}, sometimes called \textit{proof assistants} or \textit{automated proof checkers}, validate the input statement (used-defined theorem) with respect to the sequence of inference transitions (user-defined proof) according to set of rules.
Another goal of constructing the formal system is having the computer to automatically \textit{discover} the formal proof, which can rely either on induction, on meta argument, or on higher-order logic. McCune’s systems \textit{Otter}~\cite{tool_Otter} and \textit{Prover9}~\cite{tool_Prover9} are commonly recognized as the state-of-the-art tools.
In this paper only the systems that aim the first goal were considered, since they can be sufficiently applied in model checking and software verification.

This paper is organised as follows.
Sections~\ref{sec:formal_history} and~\ref{sec:formal_theory} provide a brief history of logic, thorough definitions, basic properties and theoretical limitations of the formal systems. Section~\ref{sec:auto_reasoning} covers general methods for automated reasoning. Section~\ref{sec:applications} enumerates possible application areas for automated theorem provers. Finally, Section~\ref{sec:comparison} presents the comparison of two aforementioned theorem provers, Coq and Isabelle, with respect to criteria s.a. expressiveness, computation power and usability.

<... TODO: results and author's personal contribution >


%============================================================

\section{History of formal approach}
\label{sec:formal_history}

The formal approach appeared in the beginning of previous century when mathematics experienced deep fundamental crisis caused by the need for a formal definition of the very basis. At that time, multiple paradoxes in several fields of mathematics have been discovered. Moreover, the completely new theories appeared just by modification of the set of axioms, e.g., reducing the parallel postulate of Euclidean geometry has lead to completely different non-Euclidian geometries s.a. Lobachevsky's hyperbolic geometry or Riemman's elliptic geometry, that eventually have a large number of applications in both natural sciences and engineering.

In general, a \textit{formal proof} is the sequence of statements, based on a finite set of fundamental axioms and satisfying the rules of logical inference. \textit{An axiom} is a statement evidently claimed to be true. \textit{A logical inference} is a transfer from one statement (\textit{premise}) to another (\textit{consequence}), which preserve truth, while the rule of logical inference is a principle that allows one to infer the validity of such transfer.
In formal logic, inference is based entirely on the structure (i.e., form) of those statements, thereby, the result formal system represents the abstract model describing part of real world.

%One solution for the foundational crisis was proposed by the school of formalism, it is known as Hilbert's program, and aimed to base all existing theories on finite set of axioms, and prove that these sets are consistent~\cite{Zac06}. Thus Hilbert proposed to reduce the consistency of all mathematics to basic arithmetic. 
%Unfortunately, these intentions turned out to be rather unrealisable, when in 1931 Kurt Gödel published his two famous incompleteness theorems, that demonstrated the limitations of any formal axiomatic system containing basic arithmetic~\cite{Raa15}. In particularly, he proved that all consistent axiomatic formulations of number theory are incomplete (such that there will always be statements which cannot be proved or disproved within that formulation), and that such formal system can not prove that itself it is consistent (i.e., it is unable to prove that a statement and its negative are both true).
%Notwithstanding the fact that the whole mathematics can not be described in a single axiomatic system, the formal approach allows one to build though restricted, but fine, concise and verifiable theories.

%============================================================

\section{Logical foundations}
\label{sec:formal_theory}

// TODO (Paragraph is still in progress)

% a very little banch of history
\begin{itemize}
\itemsep0em
	\item what the logical system is (formally: set of axioms, inference rules)
	\item (?) a brief history of axiomatic approach (Euclid, Hilbert)
	\item what the truth is: completeness
	\item intro to set theory (for notation) +Zermelo–Fraenkel set theory (ZFC)
	\item intro to formal languages
	\item intro to propositional and 1st ordered logic (introduce notation here. Maybe Higher-Order Logic, Non-classical Logics)
	\item type systems (+dependent type, where type checking although may be undecidable, but it verifies the correctness of ), Nominal vs. structural type system. \textbf{Curry–Howard correspondence} (the direct relationship between computer programs and mathematical proofs)
	\item else?
\end{itemize}

According to Formalists: Independence, Consistency, Completeness, Decidability.

Formalists defined four basic properties which every logical system must have:
\begin{enumerate}
\itemsep0em
	\item Independence, which means that there aren’t any superfluous axioms. There’s no axiom that can be derived from the other axioms.
	\item Consistency, which means that no theorem of the system contradicts another.
	\item Completeness, which means the ability to derive all true formulae from the axioms.
	\item Decidability, the Entscheidungsproblem, which asks for an algorithm that takes as input a statement and answers "Yes" or "No" according to whether the statement is universally valid, i.e., valid in every structure satisfying the axioms.
\end{enumerate}

Formula (i.e. statement, program) may be:
\begin{itemize}
\itemsep0em
	\item provable (either true or false, according to selected set of axioms)
	\item valid
	\item sound
	\item ...
\end{itemize}

%============================================================

\section{Methods for automated reasoning}
\label{sec:auto_reasoning}

// TODO (Paragraph is still in progress)

techniques in common words (and in introduced previously notation), e.g.: 
\begin{itemize}
\itemsep0em
	\item Clause rewriting
	\item Resolution
	\item Sequent Deduction
	\item Natural Deduction
	\item The Matrix Connection Method
	\item Term Rewriting (+lambda calculus)
	\item Mathematical Induction
\end{itemize}


% perhaps separate into subsections

%============================================================

\section{Some applications of theorem provers}
\label{sec:applications}

// TODO (Paragraph is still in progress) 

Describe possible applications of formal methods:
\begin{enumerate}
	\itemsep0em
	\item Interactive theorem proving: construct a formal axiomatic proof of correctness, 
	\item verifying that a mathematical statement is true.
	\item verifying that a circuit description, an algorithm, or a network or security protocol meets its specification:
	\begin{itemize}
		\item program verification (first-order logic), 
		\item distributed and concurrent systems (modal and temporal logics), 
		\item program specification (intuitionistic logic),
		\item Model checking: reduce to a finite state space, and test exhaustively.
		\item hardware verification (higher-order logic), 
		\item logic programming (Horn logic), 
		\item and so on.
	\end{itemize}
\end{enumerate}

%============================================================

\section{Comparison of some theorem provers}
\label{sec:comparison}

//TODO (Paragraph is still in progress) 

(in two words: here we consider Coq and Isabelle, bla-bla)

%MOCK from "Certified Programming with Dependent Types" by Adam Chlipala.
%/* ACL2 is notable in this field for having only a first-order language at its foundation. That is, you cannot work with functions over functions and all those other treats of functional programming. By giving up this facility, ACL2 can make broader assumptions about how well its proof automation will work, but we can generally recover the same advantages in other proof assistants when we happen to be programming in first-order fragments

%Isabelle/HOL and Coq both support coding new proof manipulations in ML in ways that cannot lead to the acceptance of invalid proofs. Additionally, Coq includes a domain-specific language for coding decision procedures in normal Coq source code, with no need to break out into ML.

%A language with dependent types may include references to programs inside of types. For instance, the type of an array might include a program expression giving the size of the array, making it possible to verify absence of out-of-bounds accesses statically. Dependent types can go even further than this, effectively capturing any correctness property in a type. PVS’s dependent types are much more general, but they are squeezed inside the single mechanism of subset types, where a normal type is refined by attaching a predicate over its elements. Each member of the subset type is an element of the base type that satisfies the predicate. 
%*/

%------------------------------------------------------------

\subsection{The Coq theorem prover}
\label{sec:prover_coq}

// TODO (Paragraph is still in progress)

Coq is a formal proof assistant system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs~\cite{tool_Coq}. Coq uses the Calculus of Construction, a higher-order formalism for constructive proofs in natural deduction style, developed by Thierry Coquand~\cite{Coq86}. 
The Calculus of Construction can be considered as an extension of the Curry–Howard isomorphism. % in a way that the latter associates a term in the simply typed lambda calculus with each natural-deduction proof in intuitionistic propositional logic, when the Calculus of Construction extends this isomorphism to proofs in the full intuitionistic predicate calculus, which includes proofs of quantified statements (which are also called "propositions").

(add some core features of Coq ...)

(Coq has been used to formalize ...)

%------------------------------------------------------------

\subsection{The Isabelle theorem prover}
\label{sec:prover_isabelle}

// TODO (Paragraph is still in progress)

The Isabelle is an interactive theorem prover, which relies on higher-order logic. It allows mathematical formulas to be expressed in a formal language and provides tools for proving those formulas in a logical calculus~\cite{tool_Isabelle}. Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification.

(add some core features of Isabelle ...)

(Isabelle has been used to formalize ...)

%MOCK from wiki:
%/* it is based on a small logical core to ease logical correctness. Isabelle is generic: it provides a meta-logic (a weak type theory), which is used to encode object logics like first-order logic (FOL), higher-order logic (HOL) or Zermelo–Fraenkel set theory (ZFC). Isabelle's main proof method is a higher-order version of resolution, based on higher-order unification. Though interactive, Isabelle also features efficient automatic reasoning tools, such as a term rewriting engine and a tableaux prover, as well as various decision procedures. Isabelle has been used to formalize numerous theorems from mathematics and computer science, like Gödel's completeness theorem, Gödel's theorem about the consistency of the axiom of choice, the prime number theorem, correctness of security protocols, and properties of programming language semantics. The Isabelle theorem prover is free software, released under the revised BSD license.
% */

%------------------------------------------------------------

\subsection{Joint comparison}
\label{sec:joint_comparison}

//TODO: in table:
\begin{itemize}
	\itemsep0em
	\item expressiveness of logic used
	\item time of proving
	\item num of supporting theories
	\item set of techniques to prove automatically
	\item Volume of proof (as text)
	\item num of user interaction steps
	\item usability
	\item etc ...
\end{itemize}

%============================================================

\section{Results}
\label{sec:results}

// TODO (Paragraph is still in progress)
% Pr Tripakis' note: "i think this version can be merged into section 7, perhaps as its last subsection, 7.x"
conclusion of comparison

%============================================================

\section{Future work}
\label{sec:future_work}

// TODO (Paragraph is still in progress)

< in future, we want to apply this survey to software verification >


%============================================================


\bibliographystyle{ieeetr}
\bibliography{cs-seminar}

\end{document}
